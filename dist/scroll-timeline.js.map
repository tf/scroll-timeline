{"version":3,"file":"scroll-timeline.js","sources":["../src/numeric-values.js","../src/utils.js","../src/simplify-calculation.js","../src/proxy-cssom.js","../src/scroll-timeline-base.js","../src/proxy-animation.js","../src/index.js"],"sourcesContent":["/**\n * @typedef {{[string]: integer}} UnitMap\n * @typedef {[number, UnitMap]} SumValueItem\n * @typedef {SumValueItem[]} SumValue\n * @typedef {null} Failure\n * @typedef {{[string]: integer} & {percentHint: string | undefined}} Type\n */\n\nconst failure = null;\nconst baseTypes = [\"percent\", \"length\", \"angle\", \"time\", \"frequency\", \"resolution\", \"flex\"];\n\nconst unitGroups = {\n  // https://www.w3.org/TR/css-values-4/#font-relative-lengths\n  fontRelativeLengths: {\n    units: new Set([\"em\", \"rem\", \"ex\", \"rex\", \"cap\", \"rcap\", \"ch\", \"rch\", \"ic\", \"ric\", \"lh\", \"rlh\"])\n  },\n  // https://www.w3.org/TR/css-values-4/#viewport-relative-lengths\n  viewportRelativeLengths: {\n    units: new Set(\n      [\"vw\", \"lvw\", \"svw\", \"dvw\", \"vh\", \"lvh\", \"svh\", \"dvh\", \"vi\", \"lvi\", \"svi\", \"dvi\", \"vb\", \"lvb\", \"svb\", \"dvb\",\n        \"vmin\", \"lvmin\", \"svmin\", \"dvmin\", \"vmax\", \"lvmax\", \"svmax\", \"dvmax\"])\n  },\n  // https://www.w3.org/TR/css-values-4/#absolute-lengths\n  absoluteLengths: {\n    units: new Set([\"cm\", \"mm\", \"Q\", \"in\", \"pt\", \"pc\", \"px\"]),\n    compatible: true,\n    canonicalUnit: \"px\",\n    ratios: {\n      \"cm\": 96 / 2.54, \"mm\": (96 / 2.54) / 10, \"Q\": (96 / 2.54) / 40, \"in\": 96, \"pc\": 96 / 6, \"pt\": 96 / 72, \"px\": 1\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#angles\n  angle: {\n    units: new Set([\"deg\", \"grad\", \"rad\", \"turn\"]),\n    compatible: true,\n    canonicalUnit: \"deg\",\n    ratios: {\n      \"deg\": 1, \"grad\": 360 / 400, \"rad\": 180 / Math.PI, \"turn\": 360\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#time\n  time: {\n    units: new Set([\"s\", \"ms\"]),\n    compatible: true,\n    canonicalUnit: \"s\",\n    ratios: {\n      \"s\": 1, \"ms\": 1 / 1000\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#frequency\n  frequency: {\n    units: new Set([\"hz\", \"khz\"]),\n    compatible: true,\n    canonicalUnit: \"hz\",\n    ratios: {\n      \"hz\": 1, \"khz\": 1000\n    }\n  },\n  // https://www.w3.org/TR/css-values-4/#resolution\n  resolution: {\n    units: new Set([\"dpi\", \"dpcm\", \"dppx\"]),\n    compatible: true,\n    canonicalUnit: \"dppx\",\n    ratios: {\n      \"dpi\": 1 / 96, \"dpcm\": 2.54 / 96, \"dppx\": 1\n    }\n  }\n};\n\nconst unitToCompatibleUnitsMap = new Map();\nfor (const group of Object.values(unitGroups)) {\n  if (!group.compatible) {\n    continue;\n  }\n  for (const unit of group.units) {\n    unitToCompatibleUnitsMap.set(unit, group);\n  }\n}\n\nexport function getSetOfCompatibleUnits(unit) {\n  return unitToCompatibleUnitsMap.get(unit);\n}\n\n/**\n * Implementation of `product of two unit maps` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#product-of-two-unit-maps\n *\n * @param {UnitMap} units1 map of units (strings) to powers (integers)\n * @param {UnitMap} units2 map of units (strings) to powers (integers)\n * @return {UnitMap} map of units (strings) to powers (integers)\n */\nfunction productOfTwoUnitMaps(units1, units2) {\n  // 1. Let result be a copy of units1.\n  const result = {...units1};\n  // 2. For each unit → power in units2:\n  for (const unit of Object.keys(units2)) {\n    if (result[unit]) {\n      // 1. If result[unit] exists, increment result[unit] by power.\n      result[unit] += units2[unit];\n    } else {\n      // 2. Otherwise, set result[unit] to power.\n      result[unit] = units2[unit];\n    }\n  }\n  // 3. Return result.\n  return result;\n}\n\n/**\n * Implementation of `create a type` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#create-a-type\n *\n * @param {string} unit\n * @return {Type|Failure}\n */\nexport function createAType(unit) {\n  if (unit === \"number\") {\n    return {};\n  } else if (unit === \"percent\") {\n    return {\"percent\": 1};\n  } else if (unitGroups.absoluteLengths.units.has(unit) || unitGroups.fontRelativeLengths.units.has(unit) ||\n    unitGroups.viewportRelativeLengths.units.has(unit)) {\n    return {\"length\": 1};\n  } else if (unitGroups.angle.units.has(unit)) {\n    return {\"angle\": 1};\n  } else if (unitGroups.time.units.has(unit)) {\n    return {\"time\": 1};\n  } else if (unitGroups.frequency.units.has(unit)) {\n    return {\"frequency\": 1};\n  } else if (unitGroups.resolution.units.has(unit)) {\n    return {\"resolution\": 1};\n  } else if (unit === \"fr\") {\n    return {\"flex\": 1};\n  } else {\n    return failure;\n  }\n}\n\n/**\n * Partial implementation of `create a sum value` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#create-a-sum-value\n *\n * Supports CSSUnitValue, CSSMathProduct and CSSMathInvert with a CSSUnitValue value.\n * Other types are not supported, and will throw an error.\n *\n * @param {CSSNumericValue} cssNumericValue\n * @return {SumValue} Abstract representation of a CSSNumericValue as a sum of numbers with (possibly complex) units\n */\nexport function createSumValue(cssNumericValue) {\n  if (cssNumericValue instanceof CSSUnitValue) {\n    let {unit, value} = cssNumericValue;\n    // Let unit be the value of this’s unit internal slot, and value be the value of this’s value internal slot.\n    // If unit is a member of a set of compatible units, and is not the set’s canonical unit,\n    // multiply value by the conversion ratio between unit and the canonical unit, and change unit to the canonical unit.\n    const compatibleUnits = getSetOfCompatibleUnits(cssNumericValue.unit);\n    if (compatibleUnits && unit !== compatibleUnits.canonicalUnit) {\n      value *= compatibleUnits.ratios[unit];\n      unit = compatibleUnits.canonicalUnit;\n    }\n\n    if (unit === \"number\") {\n      // If unit is \"number\", return «(value, «[ ]»)».\n      return [[value, {}]];\n    } else {\n      // Otherwise, return «(value, «[unit → 1]»)».\n      return [[value, {[unit]: 1}]];\n    }\n  } else if (cssNumericValue instanceof CSSMathInvert) {\n    if (!(cssNumericValue.value instanceof CSSUnitValue)) {\n      // Limit implementation to CSSMathInvert of CSSUnitValue\n      throw new Error(\"Not implemented\");\n    }\n    // 1. Let values be the result of creating a sum value from this’s value internal slot.\n    const values = createSumValue(cssNumericValue.value);\n    // 2. If values is failure, return failure.\n    if (values === failure) {\n      return failure;\n    }\n    // 3. If the length of values is more than one, return failure.\n    if (values.length > 1) {\n      return failure;\n    }\n    // 4. Invert (find the reciprocal of) the value of the item in values, and negate the value of each entry in its unit map.\n    const item = values[0];\n    const tempUnionMap = {};\n    for (const [unit, power] of Object.entries(item[1])) {\n      tempUnionMap[unit] = -1 * power;\n    }\n    values[0] = [1 / item[0], tempUnionMap];\n\n    // 5. Return values.\n    return values;\n  } else if (cssNumericValue instanceof CSSMathProduct) {\n    // 1. Let values initially be the sum value «(1, «[ ]»)». (I.e. what you’d get from 1.)\n\n    let values = [[1, {}]];\n\n    // 2. For each item in this’s values internal slot:\n    for (const item of cssNumericValue.values) {\n      // 1. Let new values be the result of creating a sum value from item. Let temp initially be an empty list.\n      const newValues = createSumValue(item);\n      const temp = [];\n      // 2. If new values is failure, return failure.\n      if (newValues === failure) {\n        return failure;\n      }\n      // 3. For each item1 in values:\n      for (const item1 of values) {\n        // 1. For each item2 in new values:\n        for (const item2 of newValues) {\n          // 1. Let item be a tuple with its value set to the product of the values of item1 and item2, and its unit\n          //    map set to the product of the unit maps of item1 and item2, with all entries with a zero value removed.\n          // 2. Append item to temp.\n          temp.push([item1[0] * item2[0], productOfTwoUnitMaps(item1[1], item2[1])]);\n        }\n      }\n      // 4. Set values to temp.\n      values = temp;\n    }\n    // Return values.\n    return values;\n  } else {\n    throw new Error(\"Not implemented\");\n  }\n}\n\n\n/**\n * Implementation of `to(unit)` for CSSNumericValue from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#dom-cssnumericvalue-to\n *\n * Converts an existing CSSNumeric value into another with the specified unit, if possible.\n *\n * @param {CSSNumericValue} cssNumericValue value to convert\n * @param {string} unit\n * @return {CSSUnitValue}\n */\nexport function to(cssNumericValue, unit) {\n  // Let type be the result of creating a type from unit. If type is failure, throw a SyntaxError.\n  const type = createAType(unit);\n  if (type === failure) {\n    throw new SyntaxError(\"The string did not match the expected pattern.\");\n  }\n\n  // Let sum be the result of creating a sum value from this.\n  const sumValue = createSumValue(cssNumericValue);\n\n  // If sum is failure, throw a TypeError.\n  if (!sumValue) {\n    throw new TypeError();\n  }\n\n  // If sum has more than one item, throw a TypeError.\n  if (sumValue.length > 1) {\n    throw new TypeError(\"Sum has more than one item\");\n  }\n\n  // Otherwise, let item be the result of creating a CSSUnitValue\n  // from the sole item in sum, then converting it to unit.\n  const item = convertCSSUnitValue(createCSSUnitValue(sumValue[0]), unit);\n\n\n  // If item is failure, throw a TypeError.\n  if (item === failure) {\n    throw new TypeError();\n  }\n  // Return item.\n  return item;\n}\n\n/**\n * Implementation of `create a CSSUnitValue from a sum value item` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#create-a-cssunitvalue-from-a-sum-value-item\n *\n * @param {SumValueItem} sumValueItem  a tuple of a value, and a unit map\n * @return {CSSUnitValue|Failure}\n */\nexport function createCSSUnitValue(sumValueItem) {\n  const [value, unitMap] = sumValueItem;\n  // When asked to create a CSSUnitValue from a sum value item item, perform the following steps:\n  // If item has more than one entry in its unit map, return failure.\n  const entries = Object.entries(unitMap);\n  if (entries.length > 1) {\n    return failure;\n  }\n  // If item has no entries in its unit map, return a new CSSUnitValue whose unit internal slot is set to \"number\",\n  // and whose value internal slot is set to item’s value.\n  if (entries.length === 0) {\n    return new CSSUnitValue(value, \"number\");\n  }\n  // Otherwise, item has a single entry in its unit map. If that entry’s value is anything other than 1, return failure.\n  const entry = entries[0];\n  if (entry[1] !== 1) {\n    return failure;\n  }\n  // Otherwise, return a new CSSUnitValue whose unit internal slot is set to that entry’s key, and whose value internal slot is set to item’s value.\n  else {\n    return new CSSUnitValue(value, entry[0]);\n  }\n}\n\n/**\n * Implementation of `convert a CSSUnitValue` from css-typed-om-1:\n * https://www.w3.org/TR/css-typed-om-1/#convert-a-cssunitvalue\n\n * @param {CSSUnitValue} cssUnitValue\n * @param {string} unit\n * @return {CSSUnitValue|Failure}\n */\nexport function convertCSSUnitValue(cssUnitValue, unit) {\n  // Let old unit be the value of this’s unit internal slot, and old value be the value of this’s value internal slot.\n  const oldUnit = cssUnitValue.unit;\n  const oldValue = cssUnitValue.value;\n  // If old unit and unit are not compatible units, return failure.\n  const oldCompatibleUnitGroup = getSetOfCompatibleUnits(oldUnit);\n  const compatibleUnitGroup = getSetOfCompatibleUnits(unit);\n  if (!compatibleUnitGroup || oldCompatibleUnitGroup !== compatibleUnitGroup) {\n    return failure;\n  }\n  // Return a new CSSUnitValue whose unit internal slot is set to unit, and whose value internal slot is set to\n  // old value multiplied by the conversation ratio between old unit and unit.\n  return new CSSUnitValue(oldValue * compatibleUnitGroup.ratios[oldUnit] / compatibleUnitGroup.ratios[unit], unit);\n}\n\n/**\n * Partial implementation of `toSum(...units)`:\n * https://www.w3.org/TR/css-typed-om-1/#dom-cssnumericvalue-tosum\n *\n * The implementation is restricted to conversion without units.\n * It simplifies a CSSNumericValue into a minimal sum of CSSUnitValues.\n * Will throw an error if called with units.\n *\n * @param {CSSNumericValue} cssNumericValue value to convert to a CSSMathSum\n * @param {string[]} units Not supported in this implementation\n * @return {CSSMathSum}\n */\nexport function toSum(cssNumericValue, ...units) {\n  // The toSum(...units) method converts an existing CSSNumericValue this into a CSSMathSum of only CSSUnitValues\n  // with the specified units, if possible. (It’s like to(), but allows the result to have multiple units in it.)\n  // If called without any units, it just simplifies this into a minimal sum of CSSUnitValues.\n  // When called, it must perform the following steps:\n  //\n  // For each unit in units, if the result of creating a type from unit is failure, throw a SyntaxError.\n  //\n  if (units && units.length) {\n    // Only unitless method calls are implemented in this polyfill\n    throw new Error(\"Not implemented\");\n  }\n\n  // Let sum be the result of creating a sum value from this. If sum is failure, throw a TypeError.\n  const sum = createSumValue(cssNumericValue);\n\n  // Let values be the result of creating a CSSUnitValue for each item in sum. If any item of values is failure,\n  // throw a TypeError.\n  const values = sum.map(item => createCSSUnitValue(item));\n  if (values.some(value => value === failure)) {\n    throw new TypeError(\"Type error\");\n  }\n\n  // If units is empty, sort values in code point order according to the unit internal slot of its items,\n  // then return a new CSSMathSum object whose values internal slot is set to values.\n  return new CSSMathSum(...values);\n}\n\n/**\n * Implementation of `invert a type` from css-typed-om-1 Editors Draft:\n * https://drafts.css-houdini.org/css-typed-om/\n *\n * @param {Type} type\n * @return {Type}\n */\nexport function invertType(type) {\n  // To invert a type type, perform the following steps:\n  // Let result be a new type with an initially empty ordered map and an initially null percent hint\n  // For each unit → exponent of type, set result[unit] to (-1 * exponent).\n  // Return result.\n  const result = {};\n  for (const baseType of baseTypes) {\n    result[baseType] = -1 * type[baseType];\n  }\n  return result;\n}\n\n/**\n * Implementation of `multiply two types` from css-typed-om-1 Editor's Draft:\n * https://drafts.css-houdini.org/css-typed-om/#cssnumericvalue-multiply-two-types\n *\n * @param {Type} type1 a map of base types to integers and an associated percent hint\n * @param {Type} type2 a map of base types to integers and an associated percent hint\n * @return {Type|Failure}\n */\nexport function multiplyTypes(type1, type2) {\n  if (type1.percentHint && type2.percentHint && type1.percentHint !== type2.percentHint) {\n    return failure;\n  }\n  const finalType = {\n    ...type1, percentHint: type1.percentHint ?? type2.percentHint,\n  };\n\n  for (const baseType of baseTypes) {\n    if (!type2[baseType]) {\n      continue;\n    }\n    finalType[baseType] ??= 0;\n    finalType[baseType] += type2[baseType];\n  }\n  return finalType;\n}","export function parseLength(obj, acceptStr) {\n  if (obj instanceof CSSUnitValue || obj instanceof CSSMathSum)\n    return obj;\n  if (!acceptStr)\n    return null;\n  let matches = obj.trim().match(/^(-?[0-9]*\\.?[0-9]*)(px|%)$/);\n  if (matches) {\n    let value = matches[1];\n    // The unit for % is percent.\n    let unit = matches[2] == '%' ? 'percent' : matches[2];\n    return new CSSUnitValue(value, unit);\n  }\n  return null;\n}\n\nconst canonicalUnits = new Set([\"px\", \"deg\", \"s\", \"hz\", \"dppx\", \"number\", \"fr\"]);\n\nexport function isCanonical(unit) {\n  return canonicalUnits.has(unit.toLowerCase());\n}","import {isCanonical} from \"./utils\";\n\n/**\n * @typedef {{percentageReference: CSSUnitValue, fontSize?: CSSUnitValue}} Info\n */\n\n/**\n * Groups a list of objects by a given string keyed property\n *\n * @template T\n * @param {T[]} items\n * @param {string} key string key\n * @return {Map<any,T[]>}\n */\nfunction groupBy(items, key) {\n  return items.reduce((groups, item) => {\n    if (groups.has(item[key])) {\n      groups.get(item[key]).push(item);\n    } else {\n      groups.set(item[key], [item]);\n    }\n    return groups;\n  }, new Map());\n}\n\n/**\n * Partitions a list into a tuple of lists.\n * The first item in the tuple contains a list of items that pass the test provided by the callback function.\n * The second item in the tuple contains the remaining items\n *\n * @template T\n * @param {T[]} items\n * @param {(item:T) => boolean} callbackFn Returns truthy if item should be put in the first list in the tuple, falsy if it should be put in the second list.\n * @return {[T[],T[]]}\n */\nfunction partition(items, callbackFn) {\n  const partA = [];\n  const partB = [];\n  for (const item of items) {\n    if (callbackFn(item)) {\n      partA.push(item);\n    } else {\n      partB.push(item);\n    }\n  }\n  return [partA, partB];\n}\n\n/**\n * Partial implementation of `simplify a calculation tree` applied to CSSNumericValue\n * https://www.w3.org/TR/css-values-4/#simplify-a-calculation-tree\n *\n * @param {CSSNumericValue} root\n * @param {Info} info information used to resolve\n * @return {CSSNumericValue}\n */\nexport function simplifyCalculation(root, info) {\n  function simplifyNumericArray(values) {\n    return Array.from(values).map((value) => simplifyCalculation(value, info));\n  }\n\n  // To simplify a calculation tree root:\n  if (root instanceof CSSUnitValue) {\n    // 1. If root is a numeric value:\n\n    if (root.unit === \"percent\" && info.percentageReference) {\n      // 1. If root is a percentage that will be resolved against another value, and there is enough information\n      //    available to resolve it, do so, and express the resulting numeric value in the appropriate canonical unit.\n      //    Return the value.\n      const resolvedValue = (root.value / 100) * info.percentageReference.value;\n      const resolvedUnit = info.percentageReference.unit;\n      return new CSSUnitValue(resolvedValue, resolvedUnit);\n    }\n\n    // 2. If root is a dimension that is not expressed in its canonical unit, and there is enough information available\n    //    to convert it to the canonical unit, do so, and return the value.\n\n    // Use Typed OM toSum() to convert values in compatible sets to canonical units\n    const sum = root.toSum();\n    if (sum && sum.values.length === 1) {\n      root = sum.values[0];\n    }\n    // TODO: handle relative lengths\n    if (root instanceof CSSUnitValue && root.unit === 'em' && info.fontSize) {\n      root = new CSSUnitValue(root.value * info.fontSize.value, info.fontSize.unit);\n    }\n    // 3. If root is a <calc-constant>, return its numeric value.\n    // 4. Otherwise, return root.\n    return root;\n  }\n\n  // 2. If root is any other leaf node (not an operator node):\n  if (!root.operator) {\n    //    1. If there is enough information available to determine its numeric value, return its value, expressed in the value’s canonical unit.\n    //    2. Otherwise, return root.\n    return root;\n  }\n\n  // 3. At this point, root is an operator node. Simplify all the calculation children of root.\n  switch (root.operator) {\n    case \"sum\":\n      root = new CSSMathSum(...simplifyNumericArray(root.values));\n      break;\n    case \"product\":\n      root = new CSSMathProduct(...simplifyNumericArray(root.values));\n      break;\n    case \"negate\":\n      root = new CSSMathNegate(simplifyCalculation(root.value, info));\n      break;\n    case \"clamp\":\n      root = new CSSMathClamp(simplifyCalculation(root.lower, info), simplifyCalculation(root.value, info),\n        simplifyCalculation(root.upper, info));\n      break;\n    case \"invert\":\n      root = new CSSMathInvert(simplifyCalculation(root.value, info));\n      break;\n    case \"min\":\n      root = new CSSMathMin(...simplifyNumericArray(root.values));\n      break;\n    case \"max\":\n      root = new CSSMathMax(...simplifyNumericArray(root.values));\n      break;\n  }\n\n  // 4. If root is an operator node that’s not one of the calc-operator nodes, and all of its calculation children are\n  //    numeric values with enough information to compute the operation root represents, return the result of running\n  //    root’s operation using its children, expressed in the result’s canonical unit.\n  if (root instanceof CSSMathMin || root instanceof CSSMathMax) {\n    const children = Array.from(root.values);\n    if (children.every(\n      (child) => child instanceof CSSUnitValue && child.unit !== \"percent\" && isCanonical(child.unit) && child.unit ===\n        children[0].unit)) {\n\n      const result = Math[root.operator].apply(Math, children.map(({value}) => value));\n      return new CSSUnitValue(result, children[0].unit);\n    }\n  }\n\n  //    Note: If a percentage is left at this point, it will usually block simplification of the node, since it needs to be\n  //    resolved against another value using information not currently available. (Otherwise, it would have been converted\n  //    to a different value in an earlier step.) This includes operations such as \"min\", since percentages might resolve\n  //    against a negative basis, and thus end up with an opposite comparative relationship than the raw percentage value\n  //    would seem to indicate.\n  //\n  //    However, \"raw\" percentages—ones which do not resolve against another value, such as in opacity—might not block\n  //    simplification.\n\n  // 5. If root is a Min or Max node, attempt to partially simplify it:\n  if (root instanceof CSSMathMin || root instanceof CSSMathMax) {\n    const children = Array.from(root.values);\n    const [numeric, rest] = partition(children, (child) => child instanceof CSSUnitValue && child.unit !== \"percent\");\n    const unitGroups = Array.from(groupBy(numeric, \"unit\").values());\n    //    1. For each node child of root’s children:\n    //\n    //       If child is a numeric value with enough information to compare magnitudes with another child of the same\n    //       unit (see note in previous step), and there are other children of root that are numeric children with the same\n    //       unit, combine all such children with the appropriate operator per root, and replace child with the result,\n    //       removing all other child nodes involved.\n    const hasComparableChildren = unitGroups.some(group => group.length > 0);\n    if (hasComparableChildren) {\n      const combinedGroups = unitGroups.map(group => {\n        const result = Math[root.operator].apply(Math, group.map(({value}) => value));\n        return new CSSUnitValue(result, group[0].unit);\n      });\n      if (root instanceof CSSMathMin) {\n        root = new CSSMathMin(...combinedGroups, ...rest);\n      } else {\n        root = new CSSMathMax(...combinedGroups, ...rest);\n      }\n    }\n\n    //    2. Return root.\n    return root;\n  }\n\n  // If root is a Negate node:\n  //\n  // If root’s child is a numeric value, return an equivalent numeric value, but with the value negated (0 - value).\n  // If root’s child is a Negate node, return the child’s child.\n  // Return root.\n  if (root instanceof CSSMathNegate) {\n    if (root.value instanceof CSSUnitValue) {\n      return new CSSUnitValue(0 - root.value.value, root.value.unit);\n    } else if (root.value instanceof CSSMathNegate) {\n      return root.value.value;\n    } else {\n      return root;\n    }\n  }\n\n  // If root is an Invert node:\n  //\n  // If root’s child is a number (not a percentage or dimension) return the reciprocal of the child’s value.\n  // If root’s child is an Invert node, return the child’s child.\n  // Return root.\n  if (root instanceof CSSMathInvert) {\n    if (root.value instanceof CSSMathInvert) {\n      return root.value.value;\n    } else {\n      return root;\n    }\n  }\n\n  // If root is a Sum node:\n  if (root instanceof CSSMathSum) {\n    let children = [];\n    // For each of root’s children that are Sum nodes, replace them with their children.\n    for (const value of root.values) {\n      if (value instanceof CSSMathSum) {\n        children.push(...value.values);\n      } else {\n        children.push(value);\n      }\n    }\n\n    // For each set of root’s children that are numeric values with identical units, remove those children and\n    // replace them with a single numeric value containing the sum of the removed nodes, and with the same unit.\n    //\n    // (E.g. combine numbers, combine percentages, combine px values, etc.)\n    function sumValuesWithSameUnit(values) {\n      const numericValues = values.filter((c) => c instanceof CSSUnitValue);\n      const nonNumericValues = values.filter((c) => !(c instanceof CSSUnitValue));\n\n      const summedNumericValues = Array.from(groupBy(numericValues, \"unit\").entries())\n        .map(([unit, values]) => {\n          const sum = values.reduce((a, {value}) => a + value, 0);\n          return new CSSUnitValue(sum, unit);\n        });\n      return [...nonNumericValues, ...summedNumericValues];\n    }\n\n    children = sumValuesWithSameUnit(children);\n\n    // If root has only a single child at this point, return the child. Otherwise, return root.\n    // NOTE: Zero-valued terms cannot be simply removed from a Sum; they can only be combined with other values\n    // that have identical units. (This is because the mere presence of a unit, even with a zero value,\n    // can sometimes imply a change in behavior.)\n    if (children.length === 1) {\n      return children[0];\n    } else {\n      return new CSSMathSum(...children);\n    }\n  }\n\n  // If root is a Product node:\n  //\n  // For each of root’s children that are Product nodes, replace them with their children.\n  if (root instanceof CSSMathProduct) {\n    let children = [];\n    for (const value of root.values) {\n      if (value instanceof CSSMathProduct) {\n        children.push(...value.values);\n      } else {\n        children.push(value);\n      }\n    }\n\n    // If root has multiple children that are numbers (not percentages or dimensions), remove them and replace them with\n    // a single number containing the product of the removed nodes.\n    const [numbers, rest] = partition(children, (child) => child instanceof CSSUnitValue && child.unit === \"number\");\n    if (numbers.length > 1) {\n      const product = numbers.reduce((a, {value}) => a * value, 1);\n      children = [new CSSUnitValue(product, \"number\"), ...rest];\n    }\n\n    // If root contains only two children, one of which is a number (not a percentage or dimension) and the other of\n    // which is a Sum whose children are all numeric values, multiply all of the Sum’s children by the number,\n    // then return the Sum.\n    if (children.length === 2) {\n      let numeric, sum;\n      for (const child of children) {\n        if (child instanceof CSSUnitValue && child.unit === \"number\") {\n          numeric = child;\n        } else if (child instanceof CSSMathSum && [...child.values].every((c) => c instanceof CSSUnitValue)) {\n          sum = child;\n        }\n      }\n      if (numeric && sum) {\n        return new CSSMathSum(\n          ...[...sum.values].map((value) => new CSSUnitValue(value.value * numeric.value, value.unit)));\n      }\n    }\n\n    // If root contains only numeric values and/or Invert nodes containing numeric values, and multiplying the types of\n    // all the children (noting that the type of an Invert node is the inverse of its child’s type) results in a type\n    // that matches any of the types that a math function can resolve to, return the result of multiplying all the values\n    // of the children (noting that the value of an Invert node is the reciprocal of its child’s value),\n    // expressed in the result’s canonical unit.\n    if (children.every((child) => (child instanceof CSSUnitValue && isCanonical(child.unit)) ||\n      (child instanceof CSSMathInvert && child.value instanceof CSSUnitValue && isCanonical(child.value.unit)))) {\n      // Use CSS Typed OM to multiply types\n      const sum = new CSSMathProduct(...children).toSum();\n      if (sum && sum.values.length === 1) {\n        return sum.values[0];\n      }\n    }\n\n    // Return root.\n    return new CSSMathProduct(...children);\n  }\n  // Return root.\n  return root;\n}\n","// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { createAType, invertType, multiplyTypes, to, toSum } from \"./numeric-values\";\nimport { simplifyCalculation } from \"./simplify-calculation\";\n\nexport function installCSSOM() {\n  // Object for storing details associated with an object which are to be kept\n  // private. This approach allows the constructed objects to more closely\n  // resemble their native counterparts when inspected.\n  let privateDetails = new WeakMap();\n\n  function displayUnit(unit) {\n    switch(unit) {\n      case 'percent':\n        return '%';\n      case 'number':\n        return '';\n      default:\n        return unit.toLowerCase();\n    }\n  }\n\n  function toCssUnitValue(v) {\n    if (typeof v === 'number')\n      return new CSSUnitValue(v, 'number');\n    return v;\n  }\n\n  function toCssNumericArray(values) {\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n      result[i] = toCssUnitValue(values[i]);\n    }\n    return result;\n  }\n\n  class MathOperation {\n    constructor(values, operator, opt_name, opt_delimiter) {\n      privateDetails.set(this, {\n        values: toCssNumericArray(values),\n        operator: operator,\n        name: opt_name || operator,\n        delimiter: opt_delimiter || ', '\n      });\n    }\n\n    get operator() {\n      return privateDetails.get(this).operator;\n    }\n\n    get values() {\n      return  privateDetails.get(this).values;\n    }\n\n    toString() {\n      const details = privateDetails.get(this);\n      return `${details.name}(${details.values.join(details.delimiter)})`;\n    }\n  }\n\n  /**\n   * Parse a CSSUnitValue from the passed string\n   * @param {string} str\n   * @return {CSSUnitValue}\n   */\n  function parseCSSUnitValue(str) {\n    const UNIT_VALUE_REGEXP = /^(-?\\d*[.]?\\d+)(r?em|r?ex|r?cap|r?ch|r?ic|r?lh|[sld]?v(w|h|i|b|min|max)|cm|mm|Q|in|pt|pc|px|%)?$/;\n    const match = str.match(UNIT_VALUE_REGEXP);\n    if (match) {\n      let [_, v, unit] = match;\n      if (typeof unit === 'undefined') {\n        unit = 'number';\n      } else if (unit === '%') {\n        unit = 'percent';\n      }\n      return new CSSUnitValue(parseFloat(v), unit);\n    } else {\n      throw new SyntaxError(`Unsupported syntax ${str}`);\n    }\n  }\n\n  /**\n   * Parse the string as a CSSMathProduct\n   * @param {string} str\n   * @return {CSSMathProduct}\n   */\n  function parseCSSMultiplication(str) {\n    let values = [];\n    const tokens = str.split(new RegExp('(?<!\\\\([^\\\\)]*)([*])(?![^\\\\(]*\\\\))'));\n    values.push(parseCSSDivision(tokens.shift()));\n    while (tokens.length) {\n      tokens.shift(); // Consume operator '*'\n      values.push(parseCSSDivision(tokens.shift()));\n    }\n    return new CSSMathProduct(...values);\n  }\n\n  /**\n   * Parse the string as a CSSMathProduct\n   * @param {string} str\n   * @return {CSSMathProduct}\n   */\n  function parseCSSDivision(str) {\n    let values = [];\n    const tokens = str.split(new RegExp('(?<!\\\\([^\\\\)]*)([/])(?![^\\\\(]*\\\\))'));\n    values.push(parseCSSNumericValue(tokens.shift()));\n    while (tokens.length) {\n      tokens.shift(); // Consume operator '/'\n      values.push(new CSSMathInvert(parseCSSNumericValue(tokens.shift())));\n    }\n    return new CSSMathProduct(...values);\n  }\n\n  /**\n   * Parse the string as a CSSMathSum\n   * @param {string} str\n   * @return {CSSMathSum}\n   */\n  function parseCSSMathSum(str) {\n    let values = [];\n    const tokens = str.split(new RegExp('(?<!\\\\([^\\\\)]*)(\\\\s[+-]\\\\s)(?![^\\\\(]*\\\\))'));\n    values.push(parseCSSMultiplication(tokens.shift()));\n    while (tokens.length) {\n      let op = tokens.shift();\n      let val = tokens.shift();\n      if (op.trim() === '+') {\n        values.push(parseCSSMultiplication(val));\n      } else if (op.trim() === '-') {\n        values.push(new CSSMathNegate(parseCSSMultiplication(val)));\n      }\n    }\n    return new CSSMathSum(...values);\n  }\n\n  /**\n   * Parse math function form the passed string and return a matching CSSMathValue\n   * @param {string} str\n   * @return {CSSMathValue}\n   */\n  function parseMathFunction(str) {\n    const MATH_VALUE_REGEXP = /^(calc|min|max)?\\((.*)\\)$/;\n    const match = str.match(MATH_VALUE_REGEXP);\n    if (match) {\n      let [_, operation = 'parens', value] = match;\n      switch (operation) {\n        case 'calc':\n        case 'parens':\n          return parseCSSMathSum(value);\n        case 'min':\n          return new CSSMathMin(...value.split(',').map(parseCSSNumericValue));\n        case 'max':\n          return new CSSMathMax(...value.split(',').map(parseCSSNumericValue));\n      }\n    } else {\n      throw new SyntaxError(`Unsupported syntax ${str}`);\n    }\n  }\n\n  /**\n   * A naive parsing function parsing the input string and returning a CSSNumericValue.\n   * It supports simple expressions as 'calc(10em + 10px)'\n   *\n   * @param {string} value\n   * @return {CSSNumericValue}\n   */\n  function parseCSSNumericValue(value) {\n    value = value.trim();\n    if (value.match(/^[a-z(]/i)) {\n      return parseMathFunction(value);\n    } else {\n      return parseCSSUnitValue(value);\n    }\n  }\n\n  const cssOMTypes = {\n    'CSSNumericValue': class {\n      static parse(value) {\n        return simplifyCalculation(parseCSSNumericValue(value), {});\n      }\n    },\n    'CSSUnitValue': class {\n      constructor(value, unit) {\n        privateDetails.set(this, {\n          value: value,\n          unit: unit\n        });\n      }\n\n      get value() {\n        return privateDetails.get(this).value;\n      }\n\n      set value(value) {\n        privateDetails.get(this).value = value;\n      }\n\n      get unit() {\n        return  privateDetails.get(this).unit;\n      }\n\n      to(unit) {\n        return to(this, unit)\n      }\n\n      toSum(...units) {\n        return toSum(this, ...units)\n      }\n\n      type() {\n        const details = privateDetails.get(this)\n        // The type of a CSSUnitValue is the result of creating a type from its unit internal slot.\n        return createAType(details.unit)\n      }\n\n      toString() {\n        const details = privateDetails.get(this);\n        return `${details.value}${displayUnit(details.unit)}`;\n      }\n    },\n\n    'CSSKeywordValue': class {\n      constructor(value) {\n        this.value = value;\n      }\n\n      toString() {\n        return this.value.toString();\n      }\n    },\n\n    'CSSMathSum': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'sum', 'calc', ' + ');\n      }\n    },\n\n    'CSSMathProduct': class extends MathOperation  {\n      constructor(values) {\n        super(arguments, 'product', 'calc', ' * ');\n      }\n\n      toSum(...units) {\n        return toSum(this, ...units)\n      }\n\n      type() {\n        const values = privateDetails.get(this).values;\n        // The type is the result of multiplying the types of each of the items in its values internal slot.\n        return values.map(v => v.type()).reduce(multiplyTypes)\n      }\n    },\n\n    'CSSMathNegate': class extends MathOperation {\n      constructor(values) {\n        super([arguments[0]], 'negate', '-');\n      }\n\n      get value() {\n        return  privateDetails.get(this).values[0];\n      }\n    },\n\n    'CSSMathInvert': class extends MathOperation {\n      constructor(values) {\n        super([1, arguments[0]], 'invert', 'calc', ' / ');\n      }\n\n      get value() {\n        return  privateDetails.get(this).values[1];\n      }\n\n      type() {\n        const details = privateDetails.get(this)\n        // The type of a CSSUnitValue is the result of creating a type from its unit internal slot.\n        return invertType(details.values[1].type())\n      }\n    },\n\n    'CSSMathMax': class extends MathOperation {\n      constructor() {\n        super(arguments, 'max');\n      }\n    },\n\n    'CSSMathMin': class extends MathOperation  {\n      constructor() {\n        super(arguments, 'min');\n      }\n    }\n  };\n\n  if (!window.CSS) {\n    if (!Reflect.defineProperty(window, 'CSS', { value: {} }))\n      throw Error(`Error installing CSSOM support`);\n  }\n\n  if (!window.CSSUnitValue) {\n    [\n      'number',\n      'percent',\n      // Length units\n      'em',\n      'ex',\n      'px',\n      'cm',\n      'mm',\n      'in',\n      'pt',\n      'pc',  // Picas\n      'Q',  // Quarter millimeter\n      'vw',\n      'vh',\n      'vmin',\n      'vmax',\n      'rems',\n      \"ch\",\n      // Angle units\n      'deg',\n      'rad',\n      'grad',\n      'turn',\n      // Time units\n      'ms',\n      's',\n      'Hz',\n      'kHz',\n      // Resolution\n      'dppx',\n      'dpi',\n      'dpcm',\n      // Other units\n      \"fr\"\n    ].forEach((name) => {\n      const fn = (value) => {\n        return new CSSUnitValue(value, name);\n      };\n      if (!Reflect.defineProperty(CSS, name, { value: fn }))\n        throw Error(`Error installing CSS.${name}`);\n    });\n  }\n\n  for (let type in cssOMTypes) {\n    if (type in window)\n      continue;\n    if (!Reflect.defineProperty(window, type, { value: cssOMTypes[type] }))\n      throw Error(`Error installing CSSOM support for ${type}`);\n  }\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {installCSSOM} from \"./proxy-cssom.js\";\nimport {simplifyCalculation} from \"./simplify-calculation\";\n\ninstallCSSOM();\n\nconst DEFAULT_TIMELINE_AXIS = 'block';\n\nlet scrollTimelineOptions = new WeakMap();\nlet sourceDetails = new WeakMap();\n\nfunction scrollEventSource(source) {\n  if (source === document.scrollingElement) return document;\n  return source;\n}\n\n/**\n * Updates the currentTime for all Web Animation instanced attached to a ScrollTimeline instance\n * @param scrollTimelineInstance {ScrollTimeline}\n */\nfunction updateInternal(scrollTimelineInstance) {\n  validateSource(scrollTimelineInstance);\n  const details = scrollTimelineOptions.get(scrollTimelineInstance);\n  let animations = details.animations;\n  if (animations.length === 0) return;\n  let timelineTime = scrollTimelineInstance.currentTime;\n  for (let i = 0; i < animations.length; i++) {\n    animations[i].tickAnimation(timelineTime);\n  }\n}\n\n/**\n * Calculates a scroll offset that corrects for writing modes, text direction\n * and a logical axis.\n * @param scrollTimeline {ScrollTimeline}\n * @param axis {String}\n * @returns {Number}\n */\nfunction directionAwareScrollOffset(source, axis) {\n  if (!source)\n    return null;\n  const sourceMeasurements = sourceDetails.get(source).sourceMeasurements;\n  const style = getComputedStyle(source);\n  // All writing modes are vertical except for horizontal-tb.\n  // TODO: sideways-lr should flow bottom to top, but is currently unsupported\n  // in Chrome.\n  // http://drafts.csswg.org/css-writing-modes-4/#block-flow\n  const horizontalWritingMode = style.writingMode == 'horizontal-tb';\n  let currentScrollOffset = sourceMeasurements.scrollTop;\n  if (axis == 'x' ||\n     (axis == 'inline' && horizontalWritingMode) ||\n     (axis == 'block' && !horizontalWritingMode)) {\n    // Negative values are reported for scrollLeft when the inline text\n    // direction is right to left or for vertical text with a right to left\n    // block flow. This is a consequence of shifting the scroll origin due to\n    // changes in the overflow direction.\n    // http://drafts.csswg.org/cssom-view/#overflow-directions.\n    currentScrollOffset = Math.abs(sourceMeasurements.scrollLeft);\n  }\n  return currentScrollOffset;\n}\n\n/**\n * Determines target effect end based on animation duration, iterations count and start and end delays\n *  returned value should always be positive\n * @param options {Animation} animation\n * @returns {number}\n */\nexport function calculateTargetEffectEnd(animation) {\n  return animation.effect.getComputedTiming().activeDuration;\n}\n\n/**\n * Calculates scroll offset based on axis and source geometry\n * @param source {DOMElement}\n * @param axis {String}\n * @returns {number}\n */\nexport function calculateMaxScrollOffset(source, axis) {\n  const sourceMeasurements = sourceDetails.get(source).sourceMeasurements;\n  // Only one horizontal writing mode: horizontal-tb.  All other writing modes\n  // flow vertically.\n  const horizontalWritingMode =\n    getComputedStyle(source).writingMode == 'horizontal-tb';\n  if (axis === \"block\")\n    axis = horizontalWritingMode ? \"y\" : \"x\";\n  else if (axis === \"inline\")\n    axis = horizontalWritingMode ? \"x\" : \"y\";\n  if (axis === \"y\")\n    return sourceMeasurements.scrollHeight - sourceMeasurements.clientHeight;\n  else if (axis === \"x\")\n    return sourceMeasurements.scrollWidth - sourceMeasurements.clientWidth;\n}\n\nfunction resolvePx(cssValue, resolvedLength) {\n  if (cssValue instanceof CSSUnitValue) {\n    // TODO: Add support for em, vh\n    if (cssValue.unit == \"percent\")\n      return cssValue.value * resolvedLength / 100;\n    else if (cssValue.unit == \"px\")\n      return cssValue.value;\n    else\n      throw TypeError(\"Unhandled unit type \" + cssValue.unit);\n  } else if (cssValue instanceof CSSMathSum) {\n    let total = 0;\n    for (let value of cssValue.values) {\n      total += resolvePx(value, resolvedLength);\n    }\n    return total;\n  } else if (cssValue instanceof CSSMathNegate) {\n    return -resolvePx(cssValue.value, resolvedLength);\n  }\n  throw TypeError(\"Unsupported value type: \" + typeof(cssValue));\n}\n\n// Detects if the cached source is obsolete, and updates if required\n// to ensure the new source has a scroll listener.\nfunction validateSource(timeline) {\n  if (!(timeline instanceof ViewTimeline)) {\n    validateAnonymousSource(timeline);\n    return;\n  }\n\n  const node = timeline.subject;\n  if (!node) {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const display  = getComputedStyle(node).display;\n  if (display == 'none') {\n    updateSource(timeline, null);\n    return;\n  }\n\n  const source = getScrollParent(node);\n  updateSource(timeline, source);\n}\n\nfunction validateAnonymousSource(timeline) {\n  const details = scrollTimelineOptions.get(timeline);\n  if(!details.anonymousSource)\n    return;\n\n  const source = getAnonymousSourceElement(details.anonymousSource, details.anonymousTarget);\n  updateSource(timeline, source);\n}\n\n/**\n * Read measurements of source element\n * @param {HTMLElement} source\n * @return {{clientWidth: *, scrollHeight: *, scrollLeft, clientHeight: *, scrollTop, scrollWidth: *}}\n */\nexport function measureSource (source) {\n  const style = getComputedStyle(source);\n  return {\n    scrollLeft: source.scrollLeft,\n    scrollTop: source.scrollTop,\n    scrollWidth: source.scrollWidth,\n    scrollHeight: source.scrollHeight,\n    clientWidth: source.clientWidth,\n    clientHeight: source.clientHeight,\n    writingMode: style.writingMode,\n    direction: style.direction,\n    scrollPaddingTop: style.scrollPaddingTop,\n    scrollPaddingBottom: style.scrollPaddingBottom,\n    scrollPaddingLeft: style.scrollPaddingLeft,\n    scrollPaddingRight: style.scrollPaddingRight\n  };\n}\n\n/**\n * Measure subject element relative to source\n * @param {HTMLElement} source\n * @param {HTMLElement|undefined} subject\n * @param subject\n */\nexport function measureSubject(source, subject) {\n  if (!source || !subject) {\n    return\n  }\n  let top = 0;\n  let left = 0;\n  let node = subject;\n  const ancestor = source.offsetParent;\n  while (node && node != ancestor) {\n    left += node.offsetLeft;\n    top += node.offsetTop;\n    node = node.offsetParent;\n  }\n  left -= source.offsetLeft + source.clientLeft;\n  top -= source.offsetTop + source.clientTop;\n  const style = getComputedStyle(subject);\n  return {\n    top,\n    left,\n    offsetWidth: subject.offsetWidth,\n    offsetHeight: subject.offsetHeight,\n    fontSize: style.fontSize,\n  };\n}\n\n/**\n * Update measurements of source, and update timelines\n * @param {HTMLElement} source\n */\nfunction updateMeasurements(source) {\n  let details = sourceDetails.get(source);\n  details.sourceMeasurements = measureSource(source);\n\n  // Update measurements of the subject of connected view timelines\n  for (const ref of details.timelineRefs) {\n    const timeline = ref.deref();\n    if ((timeline instanceof ViewTimeline)) {\n      const timelineDetails = scrollTimelineOptions.get(timeline)\n      timelineDetails.subjectMeasurements = measureSubject(source, timeline.subject)\n    }\n  }\n\n  requestAnimationFrame(() => {\n    // Defer ticking timeline to animation frame to prevent\n    // \"ResizeObserver loop completed with undelivered notifications\"\n    for (const ref of details.timelineRefs) {\n      const timeline = ref.deref();\n      if (timeline) {\n        updateInternal(timeline);\n      }\n    }\n  });\n}\n\nfunction updateSource(timeline, source) {\n  const oldSource = scrollTimelineOptions.get(timeline).source;\n  if (oldSource == source)\n    return;\n\n  if (oldSource) {\n    const details = sourceDetails.get(oldSource);\n    if (details) {\n      // Remove timeline reference from old source\n      details.timelineRefs.delete(timeline);\n\n      // Clean up timeline refs that have been garbage-collected\n      const undefinedRefs = Array.from(details.timelineRefs).filter(ref => typeof ref.deref() === 'undefined');\n      for (const ref of undefinedRefs) {\n        details.timelineRefs.delete(ref);\n      }\n\n      if (details.timelineRefs.size === 0) {\n        // All timelines have been disconnected from the source\n        // Clean up\n        details.disconnect();\n        sourceDetails.delete(oldSource);\n      }\n    }\n  }\n  scrollTimelineOptions.get(timeline).source = source;\n  if (source) {\n    let details = sourceDetails.get(source);\n    if (!details) {\n      // This is the first timeline for this source\n      // Store a set of weak refs to connected timelines and current measurements\n      details = {\n        timelineRefs: new Set(),\n        sourceMeasurements: measureSource(source)\n      };\n      sourceDetails.set(source, details);\n\n      // Use resize observer to detect changes to source size\n      const resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          updateMeasurements(entry.target)\n        }\n      });\n      resizeObserver.observe(source);\n\n      // Use mutation observer to detect updated style attributes on source element\n      const mutationObserver = new MutationObserver((records) => {\n        for (const record of records) {\n          updateMeasurements(record.target);\n        }\n      });\n      mutationObserver.observe(source, {attributes: true, attributeFilter: ['style', 'class']});\n\n      const scrollListener = () => {\n        // Sample and store scroll pos\n        details.sourceMeasurements.scrollLeft = source.scrollLeft;\n        details.sourceMeasurements.scrollTop = source.scrollTop;\n\n        for (const ref of details.timelineRefs) {\n          const timeline = ref.deref();\n          if (timeline) {\n            updateInternal(timeline);\n          }\n        }\n      };\n      scrollEventSource(source).addEventListener(\"scroll\", scrollListener);\n      details.disconnect = () => {\n        resizeObserver.disconnect();\n        mutationObserver.disconnect();\n        scrollEventSource(source).removeEventListener(\"scroll\", scrollListener);\n      };\n    }\n\n    // Add a weak ref to the timeline so that we can update it when the source changes\n    details.timelineRefs.add(new WeakRef(timeline));\n  }\n}\n\n/**\n * Removes a Web Animation instance from ScrollTimeline\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param options {Object}\n */\nexport function removeAnimation(scrollTimeline, animation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    if (animations[i].animation == animation) {\n      animations.splice(i, 1);\n    }\n  }\n}\n\n/**\n * Attaches a Web Animation instance to ScrollTimeline.\n * @param scrollTimeline {ScrollTimeline}\n * @param animation {Animation}\n * @param tickAnimation {function(number)}\n */\nexport function addAnimation(scrollTimeline, animation, tickAnimation) {\n  let animations = scrollTimelineOptions.get(scrollTimeline).animations;\n  for (let i = 0; i < animations.length; i++) {\n    // @TODO: This early return causes issues when a page with the polyfill\n    // is loaded from the BFCache. Ideally, this code gets fixed instead of\n    // the workaround which clears the proxyAnimations cache on pagehide.\n    // See https://github.com/flackr/scroll-timeline/issues/146#issuecomment-1698159183\n    // for details.\n    if (animations[i].animation == animation)\n      return;\n  }\n\n  animations.push({\n    animation: animation,\n    tickAnimation: tickAnimation\n  });\n  updateInternal(scrollTimeline);\n}\n\n// TODO: this is a private function used for unit testing add function\nexport function _getStlOptions(scrollTimeline) {\n  return scrollTimelineOptions.get(scrollTimeline);\n}\n\nexport class ScrollTimeline {\n  constructor(options) {\n    scrollTimelineOptions.set(this, {\n      source: null,\n      axis: DEFAULT_TIMELINE_AXIS,\n      anonymousSource: (options ? options.anonymousSource : null),\n      anonymousTarget: (options ? options.anonymousTarget : null),\n\n      // View timeline\n      subject: null,\n      inset: null,\n\n      // Internal members\n      animations: [],\n      subjectMeasurements: null\n    });\n    const source =\n      options && options.source !== undefined ? options.source\n                                              : document.scrollingElement;\n    updateSource(this, source);\n\n    if ((options && options.axis !== undefined) &&\n        (options.axis != DEFAULT_TIMELINE_AXIS)) {\n      if (!ScrollTimeline.isValidAxis(options.axis)) {\n        throw TypeError(\"Invalid axis\");\n      }\n\n      scrollTimelineOptions.get(this).axis = options.axis;\n    }\n\n    updateInternal(this);\n  }\n\n  set source(element) {\n    updateSource(this, element);\n    updateInternal(this);\n  }\n\n  get source() {\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set axis(axis) {\n    if (!ScrollTimeline.isValidAxis(axis)) {\n      throw TypeError(\"Invalid axis\");\n    }\n\n    scrollTimelineOptions.get(this).axis = axis;\n    updateInternal(this);\n  }\n\n  get axis() {\n    return scrollTimelineOptions.get(this).axis;\n  }\n\n  get duration() {\n    return CSS.percent(100);\n  }\n\n  get phase() {\n    // Per https://drafts.csswg.org/scroll-animations-1/#phase-algorithm\n    // Step 1\n    const unresolved = null;\n    //   if source is null\n    const container = this.source;\n    if (!container) return \"inactive\";\n    let scrollerStyle = getComputedStyle(container);\n\n    //   if source does not currently have a CSS layout box\n    if (scrollerStyle.display == \"none\")\n      return \"inactive\";\n\n    //   if source's layout box is not a scroll container\"\n    if (container != document.scrollingElement &&\n        (scrollerStyle.overflow == 'visible' ||\n         scrollerStyle.overflow == \"clip\")) {\n        return \"inactive\";\n    }\n\n    return \"active\"\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const container = this.source;\n    if (!container) return unresolved;\n    if (this.phase == 'inactive')\n      return unresolved;\n    const scrollerStyle = getComputedStyle(container);\n    if (\n      scrollerStyle.display === \"inline\" ||\n      scrollerStyle.display === \"none\"\n    ) {\n      return unresolved;\n    }\n\n    const axis = this.axis;\n    const scrollPos = directionAwareScrollOffset(container, axis);\n    const maxScrollPos = calculateMaxScrollOffset(container, axis);\n\n    return maxScrollPos > 0 ? CSS.percent(100 * scrollPos / maxScrollPos)\n                            : CSS.percent(100);\n  }\n\n  get __polyfill() {\n    return true;\n  }\n\n  static isValidAxis(axis) {\n    return [\"block\", \"inline\", \"x\", \"y\"].includes(axis);\n  }\n}\n\n// Methods for calculation of the containing block.\n// See https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block.\n\nfunction findClosestAncestor(element, matcher) {\n  let candidate = element.parentElement;\n  while(candidate != null) {\n    if (matcher(candidate))\n      return candidate;\n    candidate = candidate.parentElement;\n  }\n}\n\nexport function getAnonymousSourceElement(sourceType, node) {\n  return sourceType == 'root' ? document.scrollingElement : getScrollParent(node);\n}\n\nfunction isBlockContainer(element) {\n  const style = getComputedStyle(element);\n  switch (style.display) {\n    case 'block':\n    case 'inline-block':\n    case 'list-item':\n    case 'table':\n    case 'table-caption':\n    case 'flow-root':\n    case 'flex':\n    case 'grid':\n      return true;\n  }\n\n  return false;\n}\n\nfunction isFixedElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.transform != 'none' || style.perspective != 'none')\n    return true;\n\n  if (style.willChange == 'transform' || style.willChange == 'perspective')\n    return true;\n\n  if (style.filter != 'none' || style.willChange == 'filter')\n    return true;\n\n  if (style.backdropFilter != 'none')\n    return true;\n\n  return false;\n}\n\nfunction isAbsoluteElementContainer(element) {\n  const style = getComputedStyle(element);\n  if (style.position != 'static')\n    return true;\n\n  return isFixedElementContainer(element);\n}\n\nfunction getContainingBlock(element) {\n  switch (getComputedStyle(element).position) {\n    case 'static':\n    case 'relative':\n    case 'sticky':\n      return findClosestAncestor(element, isBlockContainer);\n\n    case 'absolute':\n      return findClosestAncestor(element, isAbsoluteElementContainer);\n\n    case 'fixed':\n      return findClosestAncestor(element, isFixedElementContainer);\n  }\n}\n\nexport function getScrollParent(node) {\n  if (!node)\n    return undefined;\n\n  while (node = getContainingBlock(node)) {\n    const style = getComputedStyle(node);\n    switch(style['overflow-x']) {\n      case 'auto':\n      case 'scroll':\n      case 'hidden':\n        // https://drafts.csswg.org/css-overflow-3/#overflow-propagation\n        // The UA must apply the overflow from the root element to the viewport;\n        // however, if the overflow is visible in both axis, then the overflow\n        // of the first visible child body is applied instead.\n        if (node == document.body &&\n            getComputedStyle(document.scrollingElement).overflow == \"visible\")\n          return  document.scrollingElement;\n\n        return node;\n    }\n  }\n  return document.scrollingElement;\n}\n\n// ---- View timelines -----\n\n// Computes the scroll offsets corresponding to the [0, 100]% range for a\n// specific phase on a view timeline.\n// TODO: Track changes to determine when associated animations require their\n// timing to be renormalized.\nfunction range(timeline, phase) {\n  const details = scrollTimelineOptions.get(timeline);\n  const subjectMeasurements = details.subjectMeasurements\n  const sourceMeasurements = sourceDetails.get(details.source).sourceMeasurements\n\n  const unresolved = null;\n  if (timeline.phase === 'inactive')\n    return unresolved;\n\n  if (!(timeline instanceof ViewTimeline))\n    return unresolved;\n\n  return calculateRange(phase, sourceMeasurements, subjectMeasurements, details.axis, details.inset);\n}\n\nexport function calculateRange(phase, sourceMeasurements, subjectMeasurements, axis, optionsInset) {\n  // TODO: handle position sticky\n\n  // Determine the view and container size based on the scroll direction.\n  // The view position is the scroll position of the logical starting edge\n  // of the view.\n  const horizontalWritingMode = sourceMeasurements.writingMode == 'horizontal-tb';\n  const rtl = sourceMeasurements.direction == 'rtl' || sourceMeasurements.writingMode == 'vertical-rl';\n  let viewSize = undefined;\n  let viewPos = undefined;\n  let sizes = {\n    fontSize: subjectMeasurements.fontSize\n  };\n  if (axis == 'x' ||\n      (axis == 'inline' && horizontalWritingMode) ||\n      (axis == 'block' && !horizontalWritingMode)) {\n    viewSize = subjectMeasurements.offsetWidth;\n    viewPos = subjectMeasurements.left;\n    sizes.scrollPadding = [sourceMeasurements.scrollPaddingLeft, sourceMeasurements.scrollPaddingRight];\n    if (rtl) {\n      viewPos += sourceMeasurements.scrollWidth - sourceMeasurements.clientWidth;\n      sizes.scrollPadding = [sourceMeasurements.scrollPaddingRight, sourceMeasurements.scrollPaddingLeft];\n    }\n    sizes.containerSize = sourceMeasurements.clientWidth;\n  } else {\n    // TODO: support sideways-lr\n    viewSize = subjectMeasurements.offsetHeight;\n    viewPos = subjectMeasurements.top;\n    sizes.scrollPadding = [sourceMeasurements.scrollPaddingTop, sourceMeasurements.scrollPaddingBottom];\n    sizes.containerSize = sourceMeasurements.clientHeight;\n  }\n\n  const inset = calculateInset(optionsInset, sizes);\n\n  // Cover:\n  // 0% progress represents the position at which the start border edge of the\n  // element’s principal box coincides with the end edge of its view progress\n  // visibility range.\n  // 100% progress represents the position at which the end border edge of the\n  // element’s principal box coincides with the start edge of its view progress\n  // visibility range.\n  const coverStartOffset = viewPos - sizes.containerSize + inset.end;\n  const coverEndOffset = viewPos + viewSize - inset.start;\n\n  // Contain:\n  // The 0% progress represents the earlier of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //    the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  // The 100% progress represents the greater of the following positions:\n  // 1. The start border edge of the element’s principal box coincides with\n  //  the start edge of its view progress visibility range.\n  // 2. The end border edge of the element’s principal box coincides with\n  //    the end edge of its view progress visibility range.\n  const alignStartOffset = coverStartOffset + viewSize;\n  const alignEndOffset = coverEndOffset - viewSize;\n  const containStartOffset = Math.min(alignStartOffset, alignEndOffset);\n  const containEndOffset = Math.max(alignStartOffset, alignEndOffset);\n\n  // Entry and Exit bounds align with cover and contains bounds.\n\n  let startOffset = undefined;\n  let endOffset = undefined;\n  const targetIsTallerThanContainer = viewSize > sizes.containerSize ? true : false;\n\n  switch(phase) {\n    case 'cover':\n      startOffset = coverStartOffset;\n      endOffset = coverEndOffset;\n      break;\n\n    case 'contain':\n      startOffset = containStartOffset;\n      endOffset = containEndOffset;\n      break;\n\n    case 'entry':\n      startOffset = coverStartOffset;\n      endOffset = containStartOffset;\n      break;\n\n    case 'exit':\n      startOffset = containEndOffset;\n      endOffset = coverEndOffset;\n      break;\n\n    case 'entry-crossing':\n      startOffset = coverStartOffset;\n      endOffset = targetIsTallerThanContainer ? containEndOffset : containStartOffset;\n      break;\n\n    case 'exit-crossing':\n      startOffset = targetIsTallerThanContainer ? containStartOffset : containEndOffset;\n      endOffset = coverEndOffset;\n      break;\n  }\n  return { start: startOffset, end: endOffset };\n}\n\nfunction parseInset(value) {\n  const inset = { start: 0, end: 0 };\n\n  if (!value) return inset;\n\n  let parts = value;\n  // Parse string parts to\n  if (typeof value === 'string') {\n    // Split value into separate parts\n    const stringParts = value.split(new RegExp('(?<!\\\\([^\\\\)]*)\\\\s(?![^\\\\(]*\\\\))'));\n    parts = stringParts.map(str => {\n      if (str.trim() === 'auto') {\n        return 'auto';\n      } else {\n        try {\n          return CSSNumericValue.parse(str);\n        } catch (e) {\n          throw TypeError('Invalid inset');\n        }\n      }\n    });\n  }\n  if (parts.length === 0 || parts.length > 2) {\n    throw TypeError('Invalid inset');\n  }\n\n  // Validate that the parts are 'auto' or <length-percentage>\n  for (const part of parts) {\n    if (part === 'auto') {\n      continue;\n    }\n    const type = part.type();\n    if (!(type.length === 1 || type.percent === 1)) {\n      throw TypeError('Invalid inset');\n    }\n  }\n\n  return {\n    start: parts[0],\n    end: parts[1] ?? parts[0]\n  };\n}\n\nfunction calculateInset(value, sizes) {\n  const inset = { start: 0, end: 0 };\n\n  if (!value) return inset;\n\n  const [start, end] = [value.start, value.end].map((part, i) => {\n    if (part === 'auto') {\n      return sizes.scrollPadding[i] === 'auto' ? 0 : parseFloat(sizes.scrollPadding[i]);\n    }\n\n    const simplifiedUnit = simplifyCalculation(part, {\n      percentageReference: CSS.px(sizes.containerSize),\n      fontSize: CSS.px(parseFloat(sizes.fontSize))\n    });\n    if (simplifiedUnit instanceof CSSUnitValue && simplifiedUnit.unit === 'px') {\n      return simplifiedUnit.value;\n    } else {\n      throw TypeError('Unsupported inset.');\n    }\n  });\n\n  return { start, end };\n}\n\n\n// Calculate the fractional offset of a (phase, percent) pair relative to the\n// full cover range.\nexport function relativePosition(timeline, phase, offset) {\n  const phaseRange = range(timeline, phase);\n  const coverRange = range(timeline, 'cover');\n  return calculateRelativePosition(phaseRange, offset, coverRange, timeline.subject);\n}\n\n\n\nexport function calculateRelativePosition(phaseRange, offset, coverRange, subject) {\n  if (!phaseRange || !coverRange)\n    return 0;\n\n  let style = getComputedStyle(subject)\n  const info = {\n    percentageReference: CSS.px(phaseRange.end - phaseRange.start),\n    fontSize: CSS.px(parseFloat(style.fontSize))\n  };\n  const simplifiedRangeOffset = simplifyCalculation(offset, info);\n  if (!(simplifiedRangeOffset instanceof CSSUnitValue) || simplifiedRangeOffset.unit !== 'px') {\n    throw new Error(`Unsupported offset '${simplifiedRangeOffset.toString()}'`)\n  }\n\n  const offsetPX = simplifiedRangeOffset.value + phaseRange.start;\n  return (offsetPX - coverRange.start) / (coverRange.end - coverRange.start);\n}\n\n// https://drafts.csswg.org/scroll-animations-1/#view-progress-timelines\nexport class ViewTimeline extends ScrollTimeline {\n  // As specced, ViewTimeline has a subject and a source, but\n  // ViewTimelineOptions only has source. Furthermore, there is a strict\n  // relationship between subject and source (source is nearest scrollable\n  // ancestor of subject).\n\n  // Proceeding under the assumption that subject will be added to\n  // ViewTimelineOptions. Inferring the source from the subject if not\n  // explicitly set.\n  constructor(options) {\n    super(options);\n    const details = scrollTimelineOptions.get(this);\n    details.subject = options && options.subject ? options.subject : undefined;\n    // TODO: Handle insets.\n    if (options && options.inset) {\n      details.inset = parseInset(options.inset);\n    }\n    if (details.subject) {\n      const mutationObserver = new MutationObserver(() => {\n        updateMeasurements(details.source);\n      });\n      mutationObserver.observe(details.subject, {attributes: true, attributeFilter: ['class', 'style']});\n    }\n    validateSource(this);\n    details.subjectMeasurements = measureSubject(details.source, details.subject);\n    updateInternal(this);\n  }\n\n  get source() {\n    validateSource(this);\n    return scrollTimelineOptions.get(this).source;\n  }\n\n  set source(source) {\n    throw new Error(\"Cannot set the source of a view timeline\");\n  }\n\n  get subject() {\n    return scrollTimelineOptions.get(this).subject;\n  }\n\n  // The axis is called \"axis\" for a view timeline.\n  // Internally we still call it axis.\n  get axis() {\n    return scrollTimelineOptions.get(this).axis;\n  }\n\n  get currentTime() {\n    const unresolved = null;\n    const scrollPos = directionAwareScrollOffset(this.source, this.axis);\n    if (scrollPos == unresolved)\n      return unresolved;\n\n    const offsets = range(this, 'cover');\n    if (!offsets)\n      return unresolved;\n    const progress =\n        (scrollPos - offsets.start) / (offsets.end - offsets.start);\n\n    return CSS.percent(100 * progress);\n  }\n\n  get startOffset() {\n    return CSS.px(range(this,'cover').start);\n  }\n\n  get endOffset() {\n    return CSS.px(range(this,'cover').end);\n  }\n\n}\n","import {\n  ScrollTimeline,\n  addAnimation,\n  removeAnimation,\n  relativePosition\n} from \"./scroll-timeline-base\";\n\nconst nativeDocumentGetAnimations = document.getAnimations;\nconst nativeElementGetAnimations = window.Element.prototype.getAnimations;\nconst nativeElementAnimate = window.Element.prototype.animate;\nconst nativeAnimation = window.Animation;\n\nexport const ANIMATION_RANGE_NAMES = ['entry', 'exit', 'cover', 'contain', 'entry-crossing', 'exit-crossing'];\nconst rangeNameRegExp = new RegExp(`(${ANIMATION_RANGE_NAMES.join('|')})(?!-)`);\n\nclass PromiseWrapper {\n  constructor() {\n    this.state = 'pending';\n    this.nativeResolve = this.nativeReject = null;\n    this.promise = new Promise((resolve, reject) => {\n      this.nativeResolve = resolve;\n      this.nativeReject = reject;\n    });\n  }\n  resolve(value) {\n    this.state = 'resolved';\n    this.nativeResolve(value);\n  }\n  reject(reason) {\n    this.state = 'rejected';\n    // Do not report unhandled promise rejections.\n    this.promise.catch(() => {});\n    this.nativeReject(reason);\n  }\n}\n\nfunction createReadyPromise(details) {\n  details.readyPromise = new PromiseWrapper();\n  // Trigger the pending task on the next animation frame.\n  requestAnimationFrame(() => {\n    const timelineTime = details.timeline?.currentTime ?? null;\n    if (timelineTime === null) {\n      return\n    }\n    // Run auto align start time procedure, in case measurements are ready\n    autoAlignStartTime(details);\n    if (details.pendingTask === 'play' && (details.startTime !== null || details.holdTime !== null)) {\n      commitPendingPlay(details);\n    } else if (details.pendingTask === 'pause') {\n      commitPendingPause(details);\n    }\n  });\n}\n\nfunction createAbortError() {\n  return new DOMException(\"The user aborted a request\", \"AbortError\");\n}\n\n// Converts a time from its internal representation to a percent. For a\n// monotonic timeline, time is reported as a double with implicit units of\n// milliseconds. For progress-based animations, times are reported as\n// percentages.\nfunction toCssNumberish(details, value) {\n  if (value === null)\n    return value;\n\n  if (typeof value !== 'number') {\n      throw new DOMException(\n          `Unexpected value: ${value}.  Cannot convert to CssNumberish`,\n          \"InvalidStateError\");\n  }\n\n  const rangeDuration = details.rangeDuration ?? 100;\n  const limit = effectEnd(details);\n  const percent = limit ?  rangeDuration * value / limit : 0;\n  return CSS.percent(percent);\n}\n\n// Covnerts a time to its internal representation. Progress-based animations\n// use times expressed as percentages. Each progress-based animation is backed\n// by a native animation with a document timeline in the polyfill. Thus, we\n// need to convert the timing from percent to milliseconds with implicit units.\nfunction fromCssNumberish(details, value) {\n  if (!details.timeline) {\n    // Document timeline\n    if (value == null || typeof value === 'number')\n      return value;\n\n    const convertedTime = value.to('ms');\n    if (convertedTime)\n      return convertedTime.value;\n\n    throw new DOMException(\n        \"CSSNumericValue must be either a number or a time value for \" +\n        \"time based animations.\",\n        \"InvalidStateError\");\n  } else {\n    // Scroll timeline.\n    if (value === null)\n      return value;\n\n    if (value.unit === 'percent') {\n      const rangeDuration = details.rangeDuration ?? 100;\n      const duration = effectEnd(details);\n      return value.value * duration / rangeDuration;\n    }\n\n    throw new DOMException(\n        \"CSSNumericValue must be a percentage for progress based animations.\",\n        \"NotSupportedError\");\n  }\n}\n\nfunction normalizedTiming(details) {\n  // Used normalized timing in the case of a progress-based animation or\n  // specified timing with a document timeline.  The normalizedTiming property\n  // is initialized and cached when fetching the timing information.\n  const timing = details.proxy.effect.getTiming();\n  return details.normalizedTiming || timing;\n}\n\nfunction commitPendingPlay(details)  {\n  // https://drafts4.csswg.org/web-animations-2/#playing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (details.holdTime != null) {\n    // A: If animation’s hold time is resolved,\n    // A.1. Apply any pending playback rate on animation.\n    // A.2. Let new start time be the result of evaluating:\n    //        ready time - hold time / playback rate for animation.\n    //      If the playback rate is zero, let new start time be simply ready\n    //      time.\n    // A.3. Set the start time of animation to new start time.\n    // A.4. If animation’s playback rate is not 0, make animation’s hold\n    //      time unresolved.\n    applyPendingPlaybackRate(details);\n    if (details.animation.playbackRate == 0) {\n      details.startTime = timelineTime;\n    } else {\n      details.startTime\n          = timelineTime -\n              details.holdTime / details.animation.playbackRate;\n      details.holdTime = null;\n    }\n  } else if (details.startTime !== null &&\n             details.pendingPlaybackRate !== null) {\n    // B: If animation’s start time is resolved and animation has a pending\n    //    playback rate,\n    // B.1. Let current time to match be the result of evaluating:\n    //        (ready time - start time) × playback rate for animation.\n    // B.2 Apply any pending playback rate on animation.\n    // B.3 If animation’s playback rate is zero, let animation’s hold time\n    //     be current time to match.\n    // B.4 Let new start time be the result of evaluating:\n    //       ready time - current time to match / playback rate\n    //     for animation.\n    //     If the playback rate is zero, let new start time be simply ready\n    //     time.\n    // B.5 Set the start time of animation to new start time.\n    const currentTimeToMatch =\n        (timelineTime - details.startTime) * details.animation.playbackRate;\n    applyPendingPlaybackRate(details);\n    const playbackRate = details.animation.playbackRate;\n    if (playbackRate == 0) {\n      details.holdTime = null;\n      details.startTime = timelineTime;\n    } else {\n      details.startTime = timelineTime - currentTimeToMatch / playbackRate;\n    }\n  }\n\n  // 8.4 Resolve animation’s current ready promise with animation.\n  if (details.readyPromise && details.readyPromise.state == 'pending')\n     details.readyPromise.resolve(details.proxy);\n\n  // 8.5 Run the procedure to update an animation’s finished state for\n  //     animation with the did seek flag set to false, and the\n  //     synchronously notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitPendingPause(details) {\n  // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n  // Refer to steps listed under \"Schedule a task to run ...\"\n\n  // 1. Let ready time be the time value of the timeline associated with\n  //    animation at the moment when the user agent completed processing\n  //    necessary to suspend playback of animation’s target effect.\n  const readyTime = fromCssNumberish(details, details.timeline.currentTime);\n\n  // 2. If animation’s start time is resolved and its hold time is not\n  //    resolved, let animation’s hold time be the result of evaluating\n  //    (ready time - start time) × playback rate.\n  if (details.startTime != null && details.holdTime == null) {\n    details.holdTime =\n        (readyTime - details.startTime) * details.animation.playbackRate;\n  }\n\n  // 3. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 4. Make animation’s start time unresolved.\n  details.startTime = null;\n\n  // 5. Resolve animation’s current ready promise with animation.\n  details.readyPromise.resolve(details.proxy);\n\n  // 6. Run the procedure to update an animation’s finished state for\n  // animation with the did seek flag set to false, and the synchronously\n  //  notify flag set to false.\n  updateFinishedState(details, false, false);\n\n  // Additional polyfill step to update the native animation's current time.\n  syncCurrentTime(details);\n  details.pendingTask = null;\n};\n\nfunction commitFinishedNotification(details) {\n  if (!details.finishedPromise || details.finishedPromise.state != 'pending')\n    return;\n\n  if (details.proxy.playState != 'finished')\n    return;\n\n  details.finishedPromise.resolve(details.proxy);\n\n  details.animation.pause();\n\n  // Event times are speced as doubles in web-animations-1.\n  // Cannot dispatch a proxy to an event since the proxy is not a fully\n  // transparent replacement. As a workaround, use a custom event and inject\n  // the necessary getters.\n  const finishedEvent =\n    new CustomEvent('finish',\n                    { detail: {\n                      currentTime: details.proxy.currentTime,\n                      timelineTime: details.proxy.timeline.currentTime\n                    }});\n  Object.defineProperty(finishedEvent, 'currentTime', {\n    get: function() { return this.detail.currentTime; }\n  });\n  Object.defineProperty(finishedEvent, 'timelineTime', {\n    get: function() { return this.detail.timelineTime; }\n  });\n\n  requestAnimationFrame(() => {\n    queueMicrotask(() => {\n      details.animation.dispatchEvent(finishedEvent);\n    });\n  });\n}\n\nfunction effectivePlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null)\n    return details.pendingPlaybackRate;\n  return details.animation.playbackRate;\n}\n\nfunction applyPendingPlaybackRate(details) {\n  if (details.pendingPlaybackRate !== null) {\n    details.animation.playbackRate = details.pendingPlaybackRate;\n    details.pendingPlaybackRate = null;\n  }\n}\n\n/**\n * Procedure to silently set the current time of an animation to seek time\n * https://drafts.csswg.org/web-animations-2/#silently-set-the-current-time\n * @param details\n * @param {CSSUnitValue} seekTime\n */\nfunction silentlySetTheCurrentTime(details, seekTime) {\n  // The procedure to silently set the current time of an animation, animation, to seek time is as follows:\n  //  1. If seek time is an unresolved time value, then perform the following steps.\n  //     1.  If the current time is resolved, then throw a TypeError.\n  //     2.  Abort these steps.\n  if (seekTime == null) {\n    if (details.currentTime !== null) {\n      throw new TypeError();\n    }\n  }\n  //  2. Let valid seek time be the result of running the validate a CSSNumberish time procedure with seek time as the input.\n  //  3. If valid seek time is false, abort this procedure.\n  seekTime = fromCssNumberish(details, seekTime);\n\n  //  4. Set auto align start time to false.\n  details.autoAlignStartTime = false;\n\n  //  5. Update either animation’s hold time or start time as follows:\n  //\n  //  5a If any of the following conditions are true:\n  //     - animation’s hold time is resolved, or\n  //     - animation’s start time is unresolved, or\n  //     - animation has no associated timeline or the associated timeline is inactive, or\n  //     - animation’s playback rate is 0,\n  //       1. Set animation’s hold time to seek time.\n  //\n  //  5b Otherwise,\n  //     Set animation’s start time to the result of evaluating timeline time - (seek time / playback rate) where\n  //     timeline time is the current time value of timeline associated with animation.\n  if (details.holdTime !== null || details.startTime === null ||\n    details.timeline.phase === 'inactive' || details.animation.playbackRate === 0) {\n    details.holdTime = seekTime;\n  } else {\n    details.startTime =\n      fromCssNumberish(details, details.timeline.currentTime) - seekTime / details.animation.playbackRate;\n  }\n\n  //  6. If animation has no associated timeline or the associated timeline is inactive, make animation’s start time\n  //     unresolved.\n  //     This preserves the invariant that when we don’t have an active timeline it is only possible to set either the\n  //     start time or the animation’s current time.\n  if (details.timeline.phase === 'inactive') {\n    details.startTime = null;\n  }\n\n  //  7. Make animation’s previous current time unresolved.\n  details.previousCurrentTime = null\n}\n\nfunction calculateCurrentTime(details) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime === null)\n    return null;\n\n  if (details.startTime === null)\n    return null;\n\n  let currentTime =\n      (timelineTime - details.startTime) * details.animation.playbackRate;\n\n  // Handle special case.\n  if (currentTime == -0)\n    currentTime = 0;\n\n  return currentTime;\n}\n\nfunction calculateStartTime(details, currentTime) {\n  if (!details.timeline)\n    return null;\n\n  const timelineTime = fromCssNumberish(details, details.timeline.currentTime);\n  if (timelineTime == null)\n    return null;\n\n  return timelineTime - currentTime / details.animation.playbackRate;\n}\n\nfunction updateFinishedState(details, didSeek, synchronouslyNotify) {\n  if (!details.timeline)\n    return;\n\n  // https://www.w3.org/TR/web-animations-1/#updating-the-finished-state\n  // 1. Calculate the unconstrained current time. The dependency on did_seek is\n  // required to accommodate timelines that may change direction. Without this\n  // distinction, a once-finished animation would remain finished even when its\n  // timeline progresses in the opposite direction.\n  let unconstrainedCurrentTime =\n      didSeek ? fromCssNumberish(details, details.proxy.currentTime)\n              : calculateCurrentTime(details);\n\n  // 2. Conditionally update the hold time.\n  if (unconstrainedCurrentTime && details.startTime != null &&\n      !details.proxy.pending) {\n    // Can seek outside the bounds of the active effect. Set the hold time to\n    // the unconstrained value of the current time in the event that this update\n    // is the result of explicitly setting the current time and the new time\n    // is out of bounds. An update due to a time tick should not snap the hold\n    // value back to the boundary if previously set outside the normal effect\n    // boundary. The value of previous current time is used to retain this\n    // value.\n    const playbackRate = effectivePlaybackRate(details);\n    const upperBound = effectEnd(details);\n    let boundary = details.previousCurrentTime;\n    if (playbackRate > 0 && unconstrainedCurrentTime >= upperBound &&\n        details.previousCurrentTime != null) {\n      if (boundary === null || boundary < upperBound)\n        boundary = upperBound;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate < 0 && unconstrainedCurrentTime <= 0) {\n      if (boundary == null || boundary > 0)\n        boundary = 0;\n      details.holdTime = didSeek ? unconstrainedCurrentTime : boundary;\n    } else if (playbackRate != 0) {\n      // Update start time and reset hold time.\n      if (didSeek && details.holdTime !== null)\n        details.startTime = calculateStartTime(details, details.holdTime);\n      details.holdTime = null;\n    }\n  }\n\n  // Additional step to ensure that the native animation has the same value for\n  // current time as the proxy.\n  syncCurrentTime(details);\n\n  // 3. Set the previous current time.\n  details.previousCurrentTime = fromCssNumberish(details,\n                                                 details.proxy.currentTime);\n\n  // 4. Set the current finished state.\n  const playState = details.proxy.playState;\n\n  if (playState == 'finished') {\n    if (!details.finishedPromise)\n      details.finishedPromise = new PromiseWrapper();\n    if (details.finishedPromise.state == 'pending') {\n      // 5. Setup finished notification.\n      if (synchronouslyNotify) {\n        commitFinishedNotification(details);\n      } else {\n        Promise.resolve().then(() => {\n          commitFinishedNotification(details);\n        });\n      }\n    }\n  } else {\n    // 6. If not finished but the current finished promise is already resolved,\n    //    create a new promise.\n    if (details.finishedPromise &&\n        details.finishedPromise.state == 'resolved') {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    if (details.animation.playState != 'paused')\n      details.animation.pause();\n  }\n}\n\nfunction effectEnd(details) {\n  // https://www.w3.org/TR/web-animations-1/#end-time\n  const timing = normalizedTiming(details);\n  const totalDuration =\n     timing.delay + timing.endDelay + timing.iterations * timing.duration;\n\n  return Math.max(0, totalDuration);\n}\n\nfunction hasActiveTimeline(details) {\n  return !details.timeline || details.timeline.phase != 'inactive';\n}\n\nfunction syncCurrentTime(details) {\n  if (!details.timeline)\n    return;\n\n  if (details.startTime !== null) {\n    const timelineTime = details.timeline.currentTime;\n    if (timelineTime == null)\n      return;\n\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(details,\n                         (timelineTimeMs - details.startTime) *\n                             details.animation.playbackRate);\n  } else if (details.holdTime !== null) {\n    setNativeCurrentTime(details, details.holdTime);\n  }\n}\n\n// Sets the time of the underlying animation, nudging the time slightly if at\n// a scroll-timeline boundary to remain in the active phase.\nfunction setNativeCurrentTime(details, time) {\n  const timeline = details.timeline;\n  const playbackRate = details.animation.playbackRate;\n  const atScrollTimelineBoundary =\n      timeline.currentTime &&\n      timeline.currentTime.value == (playbackRate < 0 ? 0 : 100);\n  const delta =\n      atScrollTimelineBoundary ? (playbackRate < 0 ? 0.001 : -0.001) : 0;\n\n  details.animation.currentTime = time + delta;\n}\n\nfunction resetPendingTasks(details) {\n  // https://www.w3.org/TR/web-animations-1/#reset-an-animations-pending-tasks\n\n  // 1. If animation does not have a pending play task or a pending pause task,\n  //    abort this procedure.\n  if (!details.pendingTask)\n    return;\n\n  // 2. If animation has a pending play task, cancel that task.\n  // 3. If animation has a pending pause task, cancel that task.\n  details.pendingTask = null;\n\n  // 4. Apply any pending playback rate on animation.\n  applyPendingPlaybackRate(details);\n\n  // 5. Reject animation’s current ready promise with a DOMException named\n  //    \"AbortError\".\n  details.readyPromise.reject(createAbortError());\n\n  // 6. Let animation’s current ready promise be the result of creating a new\n  //    resolved Promise object.\n  createReadyPromise(details);\n  details.readyPromise.resolve(details.proxy);\n}\n\nfunction playInternal(details, autoRewind) {\n  if (!details.timeline)\n    return;\n\n  // https://drafts.csswg.org/web-animations/#playing-an-animation-section.\n  // 1. Let aborted pause be a boolean flag that is true if animation has a\n  //    pending pause task, and false otherwise.\n  const abortedPause =\n     details.proxy.playState == 'paused' && details.proxy.pending;\n\n  // 2. Let has pending ready promise be a boolean flag that is initially\n  //    false.\n  let hasPendingReadyPromise = false;\n\n  // 3. Let has finite timeline be true if animation has an associated\n  //    timeline that is not monotonically increasing.\n  //    Note: this value will always true at this point in the polyfill.\n  //    Following steps are pruned based on the procedure for scroll\n  //    timelines.\n  //\n  // 4. Let previous current time be the animation’s current time\n  //\n  // 5. Let enable seek be true if the auto-rewind flag is true and has finite timeline is false.\n  //    Otherwise, initialize to false.\n  //\n  // 6. Perform the steps corresponding to the first matching condition from\n  //    the following, if any:\n  //\n  // 6a If animation’s effective playback rate > 0, enable seek is\n  //    true and either animation’s:\n  //      previous current time is unresolved, or\n  //      previous current time < zero, or\n  //      previous current time >= associated effect end,\n  //    6a1. Set the animation’s hold time to zero.\n  //\n  // 6b If animation’s effective playback rate < 0, enable seek is\n  //    true and either animation’s:\n  //      previous current time is unresolved, or\n  //      previous current time is ≤ zero, or\n  //      previous current time is > associated effect end,\n  //    6b1. If associated effect end is positive infinity,\n  //         throw an \"InvalidStateError\" DOMException and abort these steps.\n  //    6b2. Otherwise,\n  //         5b2a Set the animation’s hold time to the animation’s associated effect end.\n  //\n  // 6c If animation’s effective playback rate = 0 and animation’s current time\n  //    is unresolved,\n  //    6c1. Set the animation’s hold time to zero.\n  let previousCurrentTime = fromCssNumberish(details,\n                                             details.proxy.currentTime);\n\n  const playbackRate = effectivePlaybackRate(details);\n  if (playbackRate == 0 && previousCurrentTime == null) {\n    details.holdTime = 0;\n  }\n  // 12. If has finite timeline and previous current time is unresolved:\n  //     Set the flag auto align start time to true.\n  //     NOTE: If play is called for a CSS animation during style update, the animation’s start time cannot be reliably\n  //     calculated until post layout since the start time is to align with the start or end of the animation range\n  //     (depending on the playback rate). In this case, the animation is said to have an auto-aligned start time,\n  //     whereby the start time is automatically adjusted as needed to align the animation’s progress to the\n  //     animation range.\n  if (previousCurrentTime == null) {\n    details.autoAlignStartTime = true;\n  }\n\n  // Not by spec, but required by tests in play-animation.html:\n  // - Playing a finished animation restarts the animation aligned at the start\n  // - Playing a pause-pending but previously finished animation realigns with the scroll position\n  // - Playing a finished animation clears the start time\n  if (details.proxy.playState === 'finished' || abortedPause) {\n    details.holdTime = null\n    details.startTime = null\n    details.autoAlignStartTime = true;\n  }\n\n  // 13. If animation's hold time is resolved, let its start time be\n  //     unresolved.\n  if (details.holdTime) {\n    details.startTime = null;\n  }\n\n  // 14. If animation has a pending play task or a pending pause task,\n  //   8.1 Cancel that task.\n  //   8.2 Set has pending ready promise to true.\n  if (details.pendingTask) {\n    details.pendingTask = null;\n    hasPendingReadyPromise = true;\n  }\n\n  // 15. If the following three conditions are all satisfied:\n  //      animation’s hold time is unresolved, and\n  //      aborted pause is false, and\n  //      animation does not have a pending playback rate,\n  //    abort this procedure.\n  // Additonal check for polyfill: Does not have the auto align start time flag set.\n  // If we return when this flag is set, a play task will not be scheduled, leaving the animation in the\n  // idle state. If the animation is in the idle state, the auto align procedure will bail.\n  if (details.holdTime === null && !details.autoAlignStartTime &&\n      !abortedPause && details.pendingPlaybackRate === null)\n    return;\n\n  // 16. If has pending ready promise is false, let animation’s current ready\n  //    promise be a new promise in the relevant Realm of animation.\n  if (details.readyPromise && !hasPendingReadyPromise)\n    details.readyPromise = null;\n\n  // Additional polyfill step to ensure that the native animation has the\n  // correct value for current time.\n  syncCurrentTime(details);\n\n  // 17. Schedule a task to run as soon as animation is ready.\n  if (!details.readyPromise)\n    createReadyPromise(details);\n  details.pendingTask = 'play';\n\n  // Additional step for the polyfill.\n  // This must run after setting up the ready promise, otherwise we will run\n  // the procedure for calculating auto aligned start time before play state is running\n  addAnimation(details.timeline, details.animation,\n               tickAnimation.bind(details.proxy));\n\n  // 18. Run the procedure to update an animation’s finished state for animation\n  //     with the did seek flag set to false, and the synchronously notify flag\n  //     set to false.\n  updateFinishedState(details, /* seek */ false, /* synchronous */ false);\n}\n\nfunction tickAnimation(timelineTime) {\n  const details = proxyAnimations.get(this);\n  if (!details) return;\n\n  if (timelineTime == null) {\n    // While the timeline is inactive, it's effect should not be applied.\n    // To polyfill this behavior, we cancel the underlying animation.\n    if (details.proxy.playState !== 'paused' && details.animation.playState != 'idle')\n      details.animation.cancel();\n    return;\n  }\n\n  // When updating timeline current time, the start time of any attached animation is conditionally updated. For each\n  // attached animation, run the procedure for calculating an auto-aligned start time.\n  autoAlignStartTime(details);\n\n  if (details.pendingTask) {\n    // Commit pending tasks asynchronously if they are ready after aligning start time\n    requestAnimationFrame(() => {\n      if (details.pendingTask === 'play' && (details.startTime !== null || details.holdTime !== null)) {\n        commitPendingPlay(details);\n      } else if (details.pendingTask === 'pause') {\n        commitPendingPause(details);\n      }\n    });\n  }\n\n  const playState = this.playState;\n  if (playState == 'running' || playState == 'finished') {\n    const timelineTimeMs = fromCssNumberish(details, timelineTime);\n\n    setNativeCurrentTime(\n        details,\n        (timelineTimeMs - fromCssNumberish(details, this.startTime)) *\n            this.playbackRate);\n\n    // Conditionally reset the hold time so that the finished state can be\n    // properly recomputed.\n    if (playState == 'finished' && effectivePlaybackRate(details) != 0)\n      details.holdTime = null;\n    updateFinishedState(details, false, false);\n  }\n}\n\nfunction renormalizeTiming(details) {\n  // Force renormalization.\n  details.specifiedTiming = null;\n}\n\nfunction createProxyEffect(details) {\n  const effect = details.animation.effect;\n  const nativeUpdateTiming = effect.updateTiming;\n\n  // Generic pass-through handler for any method or attribute that is not\n  // explicitly overridden.\n  const handler = {\n    get: function(obj, prop) {\n      const result = obj[prop];\n      if (typeof result === 'function')\n        return result.bind(effect);\n      return result;\n    },\n\n    set: function(obj, prop, value) {\n      obj[prop] = value;\n      return true;\n    }\n  };\n  // Override getComputedTiming to convert to percentages when using a\n  // progress-based timeline.\n  const getComputedTimingHandler = {\n    apply: function(target) {\n      // Ensure that the native animation is using normalized values.\n      effect.getTiming();\n\n      const timing = target.apply(effect);\n\n      if (details.timeline) {\n        const rangeDuration = details.duration ?? 100;\n        timing.localTime = toCssNumberish(details, timing.localTime);\n        timing.endTime = toCssNumberish(details, timing.endTime);\n        timing.activeDuration =\n            toCssNumberish(details, timing.activeDuration);\n        const limit = effectEnd(details);\n        const iteration_duration = timing.iterations ?\n            (limit - timing.delay - timing.endDelay) / timing.iterations : 0;\n        timing.duration = limit ?\n            CSS.percent(rangeDuration * iteration_duration / limit) :\n            CSS.percent(0);\n\n        // Correct for inactive timeline.\n        if (details.timeline.currentTime === undefined) {\n          timing.localTime = null;\n        }\n      }\n      return timing;\n    }\n  };\n  // Override getTiming to normalize the timing. EffectEnd for the animation\n  // align with the range duration.\n  const getTimingHandler = {\n    apply: function(target, thisArg) {\n      // Arbitrary conversion of 100% to ms.\n      const INTERNAL_DURATION_MS = 100000;\n\n      if (details.specifiedTiming)\n        return details.specifiedTiming;\n\n      details.specifiedTiming = target.apply(effect);\n      let timing = Object.assign({}, details.specifiedTiming);\n\n      let totalDuration;\n\n      // Duration 'auto' case.\n      if (timing.duration === null || timing.duration === 'auto' || details.autoDurationEffect) {\n        if (details.timeline) {\n          details.autoDurationEffect = true\n          // TODO: start and end delay are specced as doubles and currently\n          // ignored for a progress based animation. Support delay and endDelay\n          // once CSSNumberish.\n          timing.delay = 0;\n          timing.endDelay = 0;\n          totalDuration = timing.iterations ? INTERNAL_DURATION_MS : 0;\n          timing.duration = timing.iterations\n             ? (totalDuration - timing.delay - timing.endDelay) /\n                 timing.iterations\n             : 0;\n          // When the rangeStart comes after the rangeEnd, we end up in a situation\n          // that cannot work. We can tell this by having ended up with a negative\n          // duration. In that case, we need to adjust the computed timings. We do\n          // this by setting the duration to 0 and then assigning the remainder of\n          // the totalDuration to the endDelay\n          if (timing.duration < 0) {\n            timing.duration = 0;\n            timing.endDelay = totalDuration - timing.delay;\n          }\n          // Set the timing on the native animation to the normalized values\n          // while preserving the specified timing.\n          nativeUpdateTiming.apply(effect, [timing]);\n        }\n      }\n      details.normalizedTiming = timing;\n      return details.specifiedTiming;\n    }\n  };\n  const updateTimingHandler = {\n    apply: function(target, thisArg, argumentsList) {\n      if (!argumentsList || !argumentsList.length)\n        return;\n\n      // Additional validation that is specific to scroll timelines.\n      if (details.timeline) {\n        const options = argumentsList[0];\n        const duration = options.duration;\n        if (duration === Infinity) {\n          throw TypeError(\n              \"Effect duration cannot be Infinity when used with Scroll \" +\n              \"Timelines\");\n        }\n        const iterations = options.iterations;\n        if (iterations === Infinity) {\n          throw TypeError(\n            \"Effect iterations cannot be Infinity when used with Scroll \" +\n            \"Timelines\");\n        }\n\n        if (typeof duration !== 'undefined' && duration !== 'auto') {\n          details.autoDurationEffect = null\n        }\n      }\n\n      // Apply updates on top of the original specified timing.\n      if (details.specifiedTiming) {\n        target.apply(effect, [details.specifiedTiming]);\n      }\n      target.apply(effect, argumentsList);\n      renormalizeTiming(details);\n    }\n  };\n  const proxy = new Proxy(effect, handler);\n  proxy.getComputedTiming = new Proxy(effect.getComputedTiming,\n                                      getComputedTimingHandler);\n  proxy.getTiming = new Proxy(effect.getTiming, getTimingHandler);\n  proxy.updateTiming = new Proxy(effect.updateTiming, updateTimingHandler);\n  return proxy;\n}\n\n// Computes the start delay as a fraction of the active cover range.\nfunction fractionalStartDelay(details) {\n  if (!(details.timeline instanceof ViewTimeline))\n    return 0;\n\n  let startTime = details.animationRange.start;\n  if (startTime === 'normal') {\n    startTime = {rangeName: 'cover', offset: CSS.percent(0)};\n  }\n  return relativePosition(details.timeline, startTime.rangeName, startTime.offset);\n}\n\n// Computes the ends delay as a fraction of the active cover range.\nfunction fractionalEndDelay(details) {\n  if (!(details.timeline instanceof ViewTimeline))\n    return 0;\n\n  let endTime = details.animationRange.end;\n  if (endTime === 'normal') {\n    endTime = {rangeName: 'cover', offset: CSS.percent(100)};\n  }\n  return 1 - relativePosition(details.timeline, endTime.rangeName, endTime.offset);\n}\n\n// Map from an instance of ProxyAnimation to internal details about that animation.\n// See ProxyAnimation constructor for details.\nlet proxyAnimations = new WeakMap();\n\n// Clear cache containing the ProxyAnimation instances when leaving the page.\n// See https://github.com/flackr/scroll-timeline/issues/146#issuecomment-1698159183\n// for details.\nwindow.addEventListener('pagehide', (e) => {\n  proxyAnimations = new WeakMap();\n}, false);\n\n// Map from the real underlying native animation to the ProxyAnimation proxy of it.\nlet proxiedAnimations = new WeakMap();\n\n/**\n * Procedure for calculating an auto-aligned start time.\n * https://drafts.csswg.org/web-animations-2/#animation-calculating-an-auto-aligned-start-time\n * @param details\n */\nfunction autoAlignStartTime(details) {\n  // When attached to a non-monotonic timeline, the start time of the animation may be layout dependent. In this case,\n  // we defer calculation of the start time until the timeline has been updated post layout. When updating timeline\n  // current time, the start time of any attached animation is conditionally updated. The procedure for calculating an\n  // auto-aligned start time is as follows:\n\n  // 1. If the auto-align start time flag is false, abort this procedure.\n  if (!details.autoAlignStartTime) {\n    return;\n  }\n\n  // 2. If the timeline is inactive, abort this procedure.\n  if (!details.timeline || !details.timeline.currentTime) {\n    return;\n  }\n\n  // 3. If play state is idle, abort this procedure.\n  // 4. If play state is paused, and hold time is resolved, abort this procedure.\n  if (details.proxy.playState === 'idle' ||\n    (details.proxy.playState === 'paused' && details.holdTime !== null)) {\n    return;\n  }\n\n  const previousRangeDuration = details.rangeDuration\n\n  // 5. Let start offset be the resolved timeline time corresponding to the start of the animation attachment range.\n  //    In the case of view timelines, it requires a calculation based on the proportion of the cover range.\n  const startOffset = CSS.percent(fractionalStartDelay(details) * 100)\n\n  // 6. Let end offset be the resolved timeline time corresponding to the end of the animation attachment range.\n  //    In the case of view timelines, it requires a calculation based on the proportion of the cover range.\n  const endOffset = CSS.percent((1 - fractionalEndDelay(details)) * 100)\n\n  // Store the range duration, until we can find a spec aligned method to calculate iteration duration\n  // TODO: Clarify how range duration should be resolved\n  details.rangeDuration = endOffset.value - startOffset.value\n  // 7. Set start time to start offset if effective playback rate ≥ 0, and end offset otherwise.\n  const playbackRate = effectivePlaybackRate(details);\n  details.startTime = fromCssNumberish(details,playbackRate >= 0 ? startOffset : endOffset)\n\n  // 8. Clear hold time.\n  details.holdTime = null\n\n  // Additional polyfill step needed to renormalize timing when range has changed\n  if (details.rangeDuration !== previousRangeDuration) {\n    renormalizeTiming(details)\n  }\n}\n\n// Create an alternate Animation class which proxies API requests.\n// TODO: Create a full-fledged proxy so missing methods are automatically\n// fetched from Animation.\nexport class ProxyAnimation {\n  constructor(effect, timeline, animOptions={}) {\n    const animation =\n        (effect instanceof nativeAnimation) ?\n           effect : new nativeAnimation(effect, animationTimeline);\n    const isScrollAnimation = timeline instanceof ScrollTimeline;\n    const animationTimeline = isScrollAnimation ? undefined : timeline;\n    proxiedAnimations.set(animation, this);\n    proxyAnimations.set(this, {\n      animation: animation,\n      timeline: isScrollAnimation ? timeline : undefined,\n      playState: isScrollAnimation ? \"idle\" : null,\n      readyPromise: null,\n      finishedPromise: null,\n      // Start and hold times are directly tracked in the proxy despite being\n      // accessible via the animation so that direct manipulation of these\n      // properties does not affect the play state of the underlying animation.\n      // Note that any changes to these values require an update of current\n      // time for the underlying animation to ensure that its hold time is set\n      // to the correct position. These values are represented as floating point\n      // numbers in milliseconds.\n      startTime: null,\n      holdTime: null,\n      rangeDuration: null,\n      previousCurrentTime: null,\n      autoAlignStartTime: false,\n      // Calls to reverse and updatePlaybackRate set a pending rate that does\n      // not immediately take effect. The value of this property is\n      // inaccessible via the web animations API and therefore explicitly\n      // tracked.\n      pendingPlaybackRate: null,\n      pendingTask: null,\n      // Record the specified timing since it may be different than the timing\n      // actually used for the animation. When fetching the timing, this value\n      // will be returned, however, the native animation will use normalized\n      // values.\n      specifiedTiming: null,\n      // The normalized timing has the corrected timing with the intrinsic\n      // iteration duration resolved.\n      normalizedTiming: null,\n      // Effect proxy that performs the necessary time conversions when using a\n      // progress-based timelines.\n      effect: null,\n      // Range when using a view-timeline. The default range is cover 0% to\n      // 100%.\n      animationRange: timeline instanceof ViewTimeline ?\n        parseAnimationRange(animOptions['animation-range']) : null,\n      proxy: this\n    });\n  }\n\n  // -----------------------------------------\n  // Web animation API\n  // -----------------------------------------\n\n  get effect() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.effect;\n\n    // Proxy the effect to support timing conversions for progress based\n    // animations.\n    if (!details.effect)\n      details.effect = createProxyEffect(details);\n\n    return details.effect;\n  }\n  set effect(newEffect) {\n    const details = proxyAnimations.get(this);\n    details.animation.effect = newEffect;\n    // Reset proxy to force re-initialization the next time it is accessed.\n    details.effect = null;\n    details.autoDurationEffect = null;\n  }\n\n  get timeline() {\n    const details = proxyAnimations.get(this);\n    // If we explicitly set a null timeline we will return the underlying\n    // animation's timeline.\n    return details.timeline || details.animation.timeline;\n  }\n  set timeline(newTimeline) {\n    // https://drafts4.csswg.org/web-animations-2/#setting-the-timeline\n    const details = proxyAnimations.get(this);\n\n    // 1. Let old timeline be the current timeline of animation, if any.\n    // 2. If new timeline is the same object as old timeline, abort this\n    //    procedure.\n    const oldTimeline = this.timeline;\n    if (oldTimeline == newTimeline)\n      return;\n\n    // 3. Let previous play state be animation’s play state.\n    const previousPlayState = this.playState;\n\n    // 4. Let previous current time be the animation’s current time.\n    const previousCurrentTime = this.currentTime;\n\n    // 5. Set previous progress based in the first condition that applies:\n    //    If previous current time is unresolved:\n    //      Set previous progress to unresolved.\n    //    If endTime time is zero:\n    //      Set previous progress to zero.\n    //    Otherwise\n    //      Set previous progress = previous current time / endTime time\n    let end = effectEnd(details);\n    let previousProgress;\n    if (previousCurrentTime === null) {\n      previousProgress = null\n    } else if (end === 0) {\n      previousProgress = 0;\n    } else {\n      previousProgress = fromCssNumberish(details, previousCurrentTime) / end;\n    }\n\n    // 9. Let from finite timeline be true if old timeline is not null and not\n    //    monotonically increasing.\n    const fromScrollTimeline = (oldTimeline instanceof ScrollTimeline);\n\n    // 10. Let to finite timeline be true if timeline is not null and not\n    //    monotonically increasing.\n    const toScrollTimeline = (newTimeline instanceof ScrollTimeline);\n\n    // 11. Let the timeline of animation be new timeline.\n    // Cannot assume that the native implementation has mutable timeline\n    // support. Deferring this step until we know that we are either\n    // polyfilling, supporting natively, or throwing an error.\n\n    // Additional step required to track whether the animation was pending in\n    // order to set up a new ready promise if needed.\n    const pending = this.pending;\n\n    if (fromScrollTimeline) {\n      removeAnimation(details.timeline, details.animation);\n    }\n\n    // 12. Perform the steps corresponding to the first matching condition from\n    //    the following, if any:\n\n    // If to finite timeline,\n    if (toScrollTimeline) {\n      // Deferred step 11.\n      details.timeline = newTimeline;\n\n      // 1. Apply any pending playback rate on animation\n      applyPendingPlaybackRate(details);\n\n      // 2. Set auto align start time to true.\n      details.autoAlignStartTime = true;\n      // 3. Set start time to unresolved.\n      details.startTime = null;\n      // 4. Set hold time to unresolved.\n      details.holdTime = null;\n\n      // 5. If previous play state is \"finished\" or \"running\"\n      if (previousPlayState === 'running' || previousPlayState === 'finished') {\n        //    1. Schedule a pending play task\n        if (!details.readyPromise || details.readyPromise.state === 'resolved') {\n          createReadyPromise(details);\n        }\n        details.pendingTask = 'play';\n        // Additional polyfill step needed to associate the animation with\n        // the scroll timeline.\n        addAnimation(details.timeline, details.animation,\n                     tickAnimation.bind(this));\n      }\n      // 6. If previous play state is \"paused\" and previous progress is resolved:\n      if (previousPlayState === 'paused' && previousProgress !== null) {\n        //    1. Set hold time to previous progress * endTime time. This step ensures that previous progress is preserved\n        //       even in the case of a pause-pending animation with a resolved start time.\n        details.holdTime = previousProgress * end;\n      }\n\n      // Additional steps required if the animation is pending as we need to\n      // associate the pending promise with proxy animation.\n      // Note: if the native promise already has an associated \"then\", we will\n      // lose this association.\n      if (pending) {\n        if (!details.readyPromise ||\n            details.readyPromise.state == 'resolved') {\n          createReadyPromise(details);\n        }\n        if (previousPlayState == 'paused')\n          details.pendingTask = 'pause';\n        else\n          details.pendingTask = 'play';\n      }\n\n      // Note that the following steps should apply when transitioning to\n      // a monotonic timeline as well; however, we do not have a direct means\n      // of applying the steps to the native animation.\n\n      // 15. If the start time of animation is resolved, make animation’s hold\n      //     time unresolved. This step ensures that the finished play state of\n      //     animation is not “sticky” but is re-evaluated based on its updated\n      //     current time.\n      if (details.startTime !== null)\n        details.holdTime = null;\n\n      // 16. Run the procedure to update an animation’s finished state for\n      //     animation with the did seek flag set to false, and the\n      //     synchronously  notify flag set to false.\n      updateFinishedState(details, false, false);\n      return;\n    }\n\n    // To monotonic timeline.\n    if (details.animation.timeline == newTimeline) {\n      // Deferred step 11 from above.  Clearing the proxy's timeline will\n      // re-associate the proxy with the native animation.\n      removeAnimation(details.timeline, details.animation);\n      details.timeline = null;\n\n      // If from finite timeline and previous current time is resolved,\n      //   Run the procedure to set the current time to previous current time.\n      if (fromScrollTimeline) {\n        if (previousCurrentTime !== null)\n          details.animation.currentTime = previousProgress * effectEnd(details);\n\n        switch (previousPlayState) {\n          case 'paused':\n            details.animation.pause();\n            break;\n\n          case 'running':\n          case 'finished':\n            details.animation.play();\n        }\n      }\n    } else {\n      throw TypeError(\"Unsupported timeline: \" + newTimeline);\n    }\n  }\n\n  get startTime() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline)\n      return toCssNumberish(details, details.startTime);\n\n    return details.animation.startTime;\n  }\n  set startTime(value) {\n    // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation\n    const details = proxyAnimations.get(this);\n    // 1. Let valid start time be the result of running the validate a CSSNumberish time procedure with new start time\n    //    as the input.\n    // 2. If valid start time is false, abort this procedure.\n    value = fromCssNumberish(details, value);\n    if (!details.timeline) {\n      details.animation.startTime = value;\n      return;\n    }\n\n    // 3. Set auto align start time to false.\n    details.autoAlignStartTime = false;\n\n    // 4. Let timeline time be the current time value of the timeline that\n    //    animation is associated with. If there is no timeline associated with\n    //    animation or the associated timeline is inactive, let the timeline\n    //    time be unresolved.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    // 5. If timeline time is unresolved and new start time is resolved, make\n    //    animation’s hold time unresolved.\n    if (timelineTime == null && details.startTime != null) {\n      details.holdTime = null;\n      // Clearing the hold time may have altered the value of current time.\n      // Ensure that the underlying animations has the correct value.\n      syncCurrentTime(details);\n    }\n\n    // 6. Let previous current time be animation’s current time.\n    // Note: This is the current time after applying the changes from the\n    // previous step which may cause the current time to become unresolved.\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n\n    // 7. Apply any pending playback rate on animation.\n    applyPendingPlaybackRate(details);\n\n    // 8. Set animation’s start time to new start time.\n    details.startTime = value;\n\n    // 9. Update animation’s hold time based on the first matching condition\n    //    from the following,\n\n    //    If new start time is resolved,\n    //    If animation’s playback rate is not zero,\n    //       make animation’s hold time unresolved.\n\n    //    Otherwise (new start time is unresolved),\n    //        Set animation’s hold time to previous current time even if\n    //        previous current time is unresolved.\n\n    if (details.startTime !== null && details.animation.playbackRate != 0)\n      details.holdTime = null;\n    else\n      details.holdTime = previousCurrentTime;\n\n    // 12. If animation has a pending play task or a pending pause task, cancel\n    //     that task and resolve animation’s current ready promise with\n    //     animation.\n    if (details.pendingTask) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n   // 13. Run the procedure to update an animation’s finished state for animation\n   //     with the did seek flag set to true, and the synchronously notify flag\n   //     set to false.\n   updateFinishedState(details, true, false);\n\n    // Ensure that currentTime is updated for the native animation.\n    syncCurrentTime(details);\n  }\n\n  get currentTime() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.currentTime;\n\n    if (details.holdTime != null)\n      return toCssNumberish(details, details.holdTime);\n\n    return toCssNumberish(details, calculateCurrentTime(details));\n  }\n  set currentTime(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.currentTime = value;\n      return;\n    }\n    // https://drafts.csswg.org/web-animations-2/#setting-the-current-time-of-an-animation\n    // 1. Run the steps to silently set the current time of animation to seek time.\n    silentlySetTheCurrentTime(details, value);\n\n    // 2. If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:\n    //    1. Set animation’s hold time to seek time.\n    //    2. Apply any pending playback rate to animation.\n    //    3. Make animation’s start time unresolved.\n    //    4. Cancel the pending pause task.\n    //    5. Resolve animation’s current ready promise with animation.\n    if (details.pendingTask == 'pause') {\n      details.holdTime = fromCssNumberish(details, value);\n      applyPendingPlaybackRate(details);\n      details.startTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 3. Run the procedure to update an animation’s finished state for animation with the did seek flag set to true,\n    // and the synchronously notify flag set to false.\n    updateFinishedState(details, true, false);\n  }\n\n  get playbackRate() {\n    return proxyAnimations.get(this).animation.playbackRate;\n  }\n  set playbackRate(value) {\n    const details = proxyAnimations.get(this);\n\n    if (!details.timeline) {\n      details.animation.playbackRate = value;\n      return;\n    }\n\n    // 1. Clear any pending playback rate on animation.\n    details.pendingPlaybackRate = null;\n\n    // 2. Let previous time be the value of the current time of animation before\n    //    changing the playback rate.\n    const previousCurrentTime = this.currentTime;\n\n    // 3. Set the playback rate to new playback rate.\n    details.animation.playbackRate = value;\n\n    // 4. If previous time is resolved, set the current time of animation to\n    //    previous time\n   if (previousCurrentTime !== null)\n      this.currentTime = previousCurrentTime;\n  }\n\n  get playState() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.playState;\n\n    const currentTime = fromCssNumberish(details, this.currentTime);\n\n    // 1. All of the following conditions are true:\n    //    * The current time of animation is unresolved, and\n    //    * the start time of animation is unresolved, and\n    //    * animation does not have either a pending play task or a pending pause\n    //      task,\n    //    then idle.\n    if (currentTime === null && details.startTime === null &&\n        details.pendingTask == null)\n      return 'idle';\n\n    // 2. Either of the following conditions are true:\n    //    * animation has a pending pause task, or\n    //    * both the start time of animation is unresolved and it does not have a\n    //      pending play task,\n    //    then paused.\n    if (details.pendingTask == 'pause' ||\n        (details.startTime === null && details.pendingTask != 'play'))\n      return 'paused';\n\n    // 3.  For animation, current time is resolved and either of the following\n    //     conditions are true:\n    //     * animation’s effective playback rate > 0 and current time >= target\n    //       effect end; or\n    //     * animation’s effective playback rate < 0 and current time <= 0,\n    //    then finished.\n    if (currentTime != null) {\n      if (details.animation.playbackRate > 0 &&\n          currentTime >= effectEnd(details))\n        return 'finished';\n      if (details.animation.playbackRate < 0 && currentTime <= 0)\n        return 'finished';\n    }\n\n    // 4.  Otherwise\n    return 'running';\n  }\n\n  get rangeStart() {\n    return proxyAnimations.get(this).animationRange.start ?? 'normal';\n  }\n\n  set rangeStart(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      return details.animation.rangeStart = value;\n    }\n\n    if (details.timeline instanceof ViewTimeline) {\n      const animationRange = details.animationRange;\n      animationRange.start = parseTimelineRangeOffset(value, 'start');\n\n      // Additional polyfill step to ensure that the native animation has the\n      // correct value for current time.\n      autoAlignStartTime(details);\n      syncCurrentTime(details);\n    }\n  }\n\n  get rangeEnd() {\n    return proxyAnimations.get(this).animationRange.end ?? 'normal';\n  }\n\n  set rangeEnd(value) {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      return details.animation.rangeEnd = value;\n    }\n\n    if (details.timeline instanceof ViewTimeline) {\n      const animationRange = details.animationRange;\n      animationRange.end = parseTimelineRangeOffset(value, 'end');\n\n      // Additional polyfill step to ensure that the native animation has the\n      // correct value for current time.\n      autoAlignStartTime(details);\n      syncCurrentTime(details);\n    }\n  }\n\n  get replaceState() {\n    // TODO: Fix me. Replace state is not a boolean.\n    return proxyAnimations.get(this).animation.pending;\n  }\n\n  get pending() {\n    const details = proxyAnimations.get(this);\n    if (details.timeline) {\n      return !!details.readyPromise &&\n             details.readyPromise.state == 'pending';\n    }\n\n    return details.animation.pending;\n  }\n\n  finish() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.finish();\n      return;\n    }\n\n    // 1. If animation’s effective playback rate is zero, or if animation’s\n    //    effective playback rate > 0 and target effect end is infinity, throw\n    //    an InvalidStateError and abort these steps.\n    const playbackRate = effectivePlaybackRate(details);\n    const duration = effectEnd(details);\n    if (playbackRate == 0) {\n      throw new DOMException(\n          \"Cannot finish Animation with a playbackRate of 0.\",\n          \"InvalidStateError\");\n    }\n    if (playbackRate > 0 && duration == Infinity) {\n      throw new DOMException(\n          \"Cannot finish Animation with an infinite target effect end.\",\n          \"InvalidStateError\");\n    }\n\n    // 2. Apply any pending playback rate to animation.\n    applyPendingPlaybackRate(details);\n\n    // 3. Set limit as follows:\n    //       If playback rate > 0,\n    //          Let limit be target effect end.\n    //       Otherwise,\n    //          Let limit be zero.\n    const limit = playbackRate < 0 ? 0 : duration;\n\n    // 4. Silently set the current time to limit.\n    this.currentTime = toCssNumberish(details, limit);\n\n    // 5. If animation’s start time is unresolved and animation has an\n    //    associated active timeline, let the start time be the result of\n    //    evaluating\n    //        timeline time - (limit / playback rate)\n    //    where timeline time is the current time value of the associated\n    //    timeline.\n    const timelineTime = fromCssNumberish(details,\n                                          details.timeline.currentTime);\n\n    if (details.startTime === null && timelineTime !== null) {\n       details.startTime =\n           timelineTime - (limit / details.animation.playbackRate);\n    }\n\n    // 6. If there is a pending pause task and start time is resolved,\n    //    6.1 Let the hold time be unresolved.\n    //    6.2 Cancel the pending pause task.\n    //    6.3 Resolve the current ready promise of animation with animation.\n    if (details.pendingTask == 'pause' && details.startTime !== null) {\n      details.holdTime = null;\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 7. If there is a pending play task and start time is resolved, cancel\n    //    that task and resolve the current ready promise of animation with\n    //    animation.\n    if (details.pendingTask == 'play' && details.startTime !== null) {\n      details.pendingTask = null;\n      details.readyPromise.resolve(this);\n    }\n\n    // 8. Run the procedure to update an animation’s finished state for\n    //    animation with the did seek flag set to true, and the synchronously\n    //    notify flag set to true.\n    updateFinishedState(details, true, true);\n  }\n\n  play() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.play();\n      return;\n    }\n\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  pause() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.pause();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#pausing-an-animation-section\n    // and https://drafts.csswg.org/web-animations-2/#pausing-an-animation-section\n\n    // 1. If animation has a pending pause task, abort these steps.\n    // 2. If the play state of animation is paused, abort these steps.\n    if (this.playState == \"paused\")\n      return;\n\n    // Replaced steps from https://drafts.csswg.org/web-animations-2/#pausing-an-animation-section\n    //\n    // 3. Let has finite timeline be true if animation has an associated timeline that is not monotonically increasing.\n    //    Note: always true if we have reached this point in the polyfill.\n    //    Pruning following steps to be specific to scroll timelines.\n    // 4. If the animation’s current time is unresolved and has finite timeline is false, perform the steps according\n    //    to the first matching condition below:\n    //\n    //    4a If animation’s playback rate is ≥ 0,\n    //       Set hold time to zero.\n    //    4b Otherwise,\n    //       4b1 If associated effect end for animation is positive infinity,\n    //           throw an \"InvalidStateError\" DOMException and abort these steps.\n    //       4b2 Otherwise,\n    //           Set hold time to animation’s associated effect end.\n    // If has finite timeline is true, and the animation’s current time is unresolved\n    // Set the auto align start time flag to true.\n    if (details.animation.currentTime === null) {\n      details.autoAlignStartTime = true;\n    }\n\n    // 7. Let has pending ready promise be a boolean flag that is initially\n    //    false.\n    // 8. If animation has a pending play task, cancel that task and let has\n    //    pending ready promise be true.\n    // 9. If has pending ready promise is false, set animation’s current ready\n    //    promise to a new promise in the relevant Realm of animation.\n    if (details.pendingTask == 'play')\n      details.pendingTask = null;\n    else\n      details.readyPromise = null;\n\n    // 10. Schedule a task to be executed at the first possible moment where all of the following conditions are true:\n    //\n    //     the user agent has performed any processing necessary to suspend the playback of animation’s associated\n    //     effect, if any.\n    //     the animation is associated with a timeline that is not inactive.\n    //     the animation has a resolved hold time or start time.\n    if (!details.readyPromise)\n      createReadyPromise(details);\n    details.pendingTask ='pause';\n\n    // Additional step for the polyfill.\n    // This must run after setting up the ready promise, otherwise we will run\n    // the procedure for calculating auto aligned start time before play state is running\n    addAnimation(details.timeline, details.animation, tickAnimation.bind(details.proxy));\n  }\n\n  reverse() {\n    const details = proxyAnimations.get(this);\n    const playbackRate = effectivePlaybackRate(details);\n    const previousCurrentTime = fromCssNumberish(details, this.currentTime);\n    const inifiniteDuration = effectEnd(details) == Infinity;\n\n    // Let the native implementation handle throwing the exception in cases\n    // where reversal is not possible. Error cases will not change the state\n    // of the native animation.\n    const reversable =\n       (playbackRate != 0) &&\n       (playbackRate <  0 || previousCurrentTime > 0  || !inifiniteDuration);\n    if (!details.timeline || !reversable) {\n      if (reversable)\n        details.pendingPlaybackRate = -effectivePlaybackRate(details);\n      details.animation.reverse();\n      return;\n    }\n\n    if (details.timeline.phase == 'inactive') {\n      throw new DOMException(\n          \"Cannot reverse an animation with no active timeline\",\n          \"InvalidStateError\");\n    }\n\n    this.updatePlaybackRate(-playbackRate);\n    playInternal(details, /* autoRewind */ true);\n  }\n\n  updatePlaybackRate(rate) {\n    const details = proxyAnimations.get(this);\n    details.pendingPlaybackRate = rate;\n    if (!details.timeline) {\n      details.animation.updatePlaybackRate(rate);\n      return;\n    }\n\n    // https://drafts.csswg.org/web-animations/#setting-the-playback-rate-of-an-animation\n\n    // 1. Let previous play state be animation’s play state.\n    // 2. Let animation’s pending playback rate be new playback rate.\n    // Step 2 already performed as we need to record it even when using a\n    // monotonic timeline.\n    const previousPlayState = this.playState;\n\n    // 3. Perform the steps corresponding to the first matching condition from\n    //    below:\n    //\n    // 3a If animation has a pending play task or a pending pause task,\n    //    Abort these steps.\n    if (details.readyPromise && details.readyPromise.state == 'pending')\n      return;\n\n    switch(previousPlayState) {\n      // 3b If previous play state is idle or paused,\n      //    Apply any pending playback rate on animation.\n      case 'idle':\n      case 'paused':\n        applyPendingPlaybackRate(details);\n        break;\n\n      // 3c If previous play state is finished,\n      //    3c.1 Let the unconstrained current time be the result of calculating\n      //         the current time of animation substituting an unresolved time\n      //          value for the hold time.\n      //    3c.2 Let animation’s start time be the result of evaluating the\n      //         following expression:\n      //    timeline time - (unconstrained current time / pending playback rate)\n      // Where timeline time is the current time value of the timeline\n      // associated with animation.\n      //    3c.3 If pending playback rate is zero, let animation’s start time be\n      //         timeline time.\n      //    3c.4 Apply any pending playback rate on animation.\n      //    3c.5 Run the procedure to update an animation’s finished state for\n      //         animation with the did seek flag set to false, and the\n      //         synchronously notify flag set to false.\n\n      case 'finished':\n        const timelineTime = fromCssNumberish(details,\n                                              details.timeline.currentTime);\n        const unconstrainedCurrentTime = timelineTime !== null ?\n            (timelineTime - details.startTime) * details.animation.playbackRate\n            : null;\n        if (rate == 0) {\n          details.startTime = timelineTime;\n        } else {\n          details.startTime =\n              timelineTime != null && unconstrainedCurrentTime != null ?\n                  (timelineTime - unconstrainedCurrentTime) / rate : null;\n        }\n        applyPendingPlaybackRate(details);\n        updateFinishedState(details, false, false);\n        syncCurrentTime(details);\n        break;\n\n      // 3d Otherwise,\n      // Run the procedure to play an animation for animation with the\n      // auto-rewind flag set to false.\n      default:\n        playInternal(details, false);\n    }\n  }\n\n  persist() {\n    proxyAnimations.get(this).animation.persist();\n  }\n\n  get id() {\n    return proxyAnimations.get(this).animation.id;\n  }\n  \n  set id(value) {\n    proxyAnimations.get(this).animation.id = value;\n  }\n\n  cancel() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline) {\n      details.animation.cancel();\n      return;\n    }\n\n    // https://www.w3.org/TR/web-animations-1/#canceling-an-animation-section\n    // 1. If animation’s play state is not idle, perform the following steps:\n    //    1.1  Run the procedure to reset an animation’s pending tasks on\n    //         animation.\n    //    1.2 Reject the current finished promise with a DOMException named\n    //        \"AbortError\"\n    //    1.3 Let current finished promise be a new (pending) Promise object.\n    //    1.4+ Deferred to native implementation.\n    //         TODO: polyfill since timelineTime will be incorrect for the\n    //               cancel event. Also, should avoid sending a cancel event if\n    //               the native animation is canceled due to the scroll timeline\n    //               becoming inactive. This can likely be done by associating\n    //               the cancel event with the proxy and not the underlying\n    //               animation.\n    if (this.playState != 'idle') {\n      resetPendingTasks(details);\n      if (details.finishedPromise &&\n          details.finishedPromise.state == 'pending') {\n        details.finishedPromise.reject(createAbortError());\n      }\n      details.finishedPromise = new PromiseWrapper();\n      details.animation.cancel();\n    }\n\n    // 2. Make animation’s hold time unresolved.\n    // 3. Make animation’s start time unresolved.\n    details.startTime = null;\n    details.holdTime = null;\n\n    // Extra step in the polyfill the ensure the animation stops ticking.\n    removeAnimation(details.timeline, details.animation);\n  }\n\n  get onfinish() {\n    return proxyAnimations.get(this).animation.onfinish;\n  }\n  set onfinish(value) {\n    proxyAnimations.get(this).animation.onfinish = value;\n  }\n  get oncancel() {\n    return proxyAnimations.get(this).animation.oncancel;\n  }\n  set oncancel(value) {\n    proxyAnimations.get(this).animation.oncancel = value;\n  }\n  get onremove() {\n    return proxyAnimations.get(this).animation.onremove;\n  }\n  set onremove(value) {\n    proxyAnimations.get(this).animation.onremove = value;\n  }\n\n  get finished() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n       return details.animation.finished;\n\n    if (!details.finishedPromise) {\n      details.finishedPromise = new PromiseWrapper();\n    }\n    return details.finishedPromise.promise;\n  }\n\n  get ready() {\n    const details = proxyAnimations.get(this);\n    if (!details.timeline)\n      return details.animation.ready;\n\n    if (!details.readyPromise) {\n      details.readyPromise = new PromiseWrapper();\n      details.readyPromise.resolve(this);\n    }\n    return details.readyPromise.promise;\n  }\n\n  // --------------------------------------------------\n  // Event target API\n  // --------------------------------------------------\n\n  addEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.addEventListener(type, callback,\n                                                         options);\n  }\n\n  removeEventListener(type, callback, options) {\n    proxyAnimations.get(this).animation.removeEventListener(type, callback,\n                                                            options);\n  }\n\n  dispatchEvent(event) {\n    proxyAnimations.get(this).animation.dispatchEvent(event);\n  }\n};\n\n// Parses an individual TimelineRangeOffset\n// TODO: Support all formatting options\nfunction parseTimelineRangeOffset(value, position) {\n  if(!value || value === 'normal') return 'normal';\n\n  // Extract parts from the passed in value.\n  let rangeName = 'cover'\n  let offset = position === 'start' ? CSS.percent(0) : CSS.percent(100)\n\n  // Author passed in something like `{ rangeName: 'cover', offset: CSS.percent(100) }`\n  if (value instanceof Object) {\n    if (value.rangeName !== undefined) {\n      rangeName = value.rangeName;\n    }\n\n    if (value.offset !== undefined) {\n      offset = value.offset;\n    }\n  }\n  // Author passed in something like `\"cover 100%\"`\n  else {\n    const parts = value.split(rangeNameRegExp).map(part => part.trim()).filter(Boolean);\n\n    if (parts.length === 1) {\n      if (ANIMATION_RANGE_NAMES.includes(parts[0])) {\n        rangeName = parts[0];\n      } else {\n        offset = CSSNumericValue.parse(parts[0]);\n      }\n    } else if (parts.length === 2) {\n      rangeName = parts[0];\n      offset = CSSNumericValue.parse(parts[1]);\n    }\n  }\n\n  // Validate rangeName\n  if (!ANIMATION_RANGE_NAMES.includes(rangeName)) {\n    throw TypeError(\"Invalid range name\");\n  }\n\n  return { rangeName, offset };\n}\n\n// Parses a given animation-range value (string)\nfunction parseAnimationRange(value) {\n  if (!value)\n    return {\n      start: 'normal',\n      end: 'normal'\n    };\n  \n  const animationRange = {\n    start: { rangeName: 'cover', offset: CSS.percent(0) },\n    end: { rangeName: 'cover', offset: CSS.percent(100) },\n  };\n\n  // Format:\n  // <start-name> <start-offset> <end-name> <end-offset>\n  // <name> --> <name> 0% <name> 100%\n  // <name> <start-offset> <end-offset> --> <name> <start-offset>\n  //                                        <name> <end-offset>\n  // <start-offset> <end-offset> --> cover <start-offset> cover <end-offset>\n  // TODO: Support all formatting options once ratified in the spec.\n  const parts = value.split(' ');\n  const rangeNames = [];\n  const offsets = [];\n\n  parts.forEach(part => {\n    if (part.endsWith('%'))\n      offsets.push(parseFloat(part));\n    else\n      rangeNames.push(part);\n  });\n\n  if (rangeNames.length > 2 || offsets.length > 2 || offsets.length == 1) {\n    throw TypeError(\"Invalid time range or unsupported time range format.\");\n  }\n\n  if (rangeNames.length) {\n    animationRange.start.rangeName = rangeNames[0];\n    animationRange.end.rangeName = rangeNames.length > 1 ? rangeNames[1] : rangeNames[0];\n  }\n\n  // TODO: allow calc() in the offsets\n  if (offsets.length > 1) {\n    animationRange.start.offset = CSS.percent(offsets[0]);\n    animationRange.end.offset = CSS.percent(offsets[1]);\n  }\n\n  return animationRange;\n}\n\nexport function animate(keyframes, options) {\n  const timeline = options.timeline;\n\n  if (timeline instanceof ScrollTimeline)\n    delete options.timeline;\n\n  const animation = nativeElementAnimate.apply(this, [keyframes, options]);\n  const proxyAnimation = new ProxyAnimation(animation, timeline);\n\n  if (timeline instanceof ScrollTimeline) {\n    animation.pause();\n    if (timeline instanceof ViewTimeline) {\n      const details = proxyAnimations.get(proxyAnimation);\n\n      details.animationRange = {\n        start: parseTimelineRangeOffset(options.rangeStart, 'start'),\n        end: parseTimelineRangeOffset(options.rangeEnd, 'end'),\n      };\n    }\n    proxyAnimation.play();\n  }\n\n  return proxyAnimation;\n}\n\nfunction replaceProxiedAnimations(animationsList) {\n  for (let i = 0; i < animationsList.length; ++i) {\n    let proxyAnimation = proxiedAnimations.get(animationsList[i]);\n    if (proxyAnimation) {\n      animationsList[i] = proxyAnimation;\n    }\n  }\n  return animationsList;\n}\n\nexport function elementGetAnimations(options) {\n  let animations = nativeElementGetAnimations.apply(this, [options]);\n  return replaceProxiedAnimations(animations);\n}\n\nexport function documentGetAnimations(options) {\n  let animations = nativeDocumentGetAnimations.apply(this, [options]);\n  return replaceProxiedAnimations(animations);\n}\n","// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  ScrollTimeline,\n  ViewTimeline,\n} from \"./scroll-timeline-base\";\nimport {\n  animate,\n  elementGetAnimations,\n  documentGetAnimations,\n  ProxyAnimation\n} from \"./proxy-animation.js\";\n\nfunction initPolyfill() {\n  if (typeof CSS.supports !== 'function' ||\n      CSS.supports(\"animation-timeline: --works\") ||\n      typeof WeakRef === 'undefined') {\n    return;\n  }\n\n  if (\n    !Reflect.defineProperty(window, 'ScrollTimeline', { value: ScrollTimeline })\n  ) {\n    throw Error(\n      'Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window'\n    );\n  }\n  if (\n    !Reflect.defineProperty(window, 'ViewTimeline', { value: ViewTimeline })\n  ) {\n    throw Error(\n      'Error installing ViewTimeline polyfill: could not attach ViewTimeline to window'\n    );\n  }\n\n  if (\n    !Reflect.defineProperty(Element.prototype, 'animate', { value: animate })\n  ) {\n    throw Error(\n      \"Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element\"\n    );\n  }\n  if (!Reflect.defineProperty(window, 'Animation', { value: ProxyAnimation })) {\n    throw Error('Error installing Animation constructor.');\n  }\n  if (!Reflect.defineProperty(Element.prototype, \"getAnimations\", { value: elementGetAnimations })) {\n    throw Error(\n      \"Error installing ScrollTimeline polyfill: could not attach WAAPI's getAnimations to DOM Element\"\n    );\n  }\n  if (!Reflect.defineProperty(document, \"getAnimations\", { value: documentGetAnimations })) {\n    throw Error(\n      \"Error installing ScrollTimeline polyfill: could not attach WAAPI's getAnimations to document\"\n    );\n  }\n}\n\ninitPolyfill();\n"],"names":["failure","baseTypes","unitGroups","fontRelativeLengths","units","Set","viewportRelativeLengths","absoluteLengths","compatible","canonicalUnit","ratios","cm","mm","Q","in","pc","pt","px","angle","deg","grad","rad","Math","PI","turn","time","s","ms","frequency","hz","khz","resolution","dpi","dpcm","dppx","unitToCompatibleUnitsMap","Map","Object","values","group","_Object$values","_i","set","getSetOfCompatibleUnits","unit","get","productOfTwoUnitMaps","units1","units2","result","keys","_i2","_Object$keys","length","createAType","percent","has","flex","createSumValue","cssNumericValue","CSSUnitValue","_ref","value","compatibleUnits","CSSMathInvert","Error","item","tempUnionMap","entries","_Object$entries$_i","_Object$entries","_i3","power","CSSMathProduct","_step2","_iterator2","done","newValues","temp","_step3","_iterator3","item1","item2","push","to","SyntaxError","sumValue","TypeError","cssUnitValue","oldUnit","oldValue","oldCompatibleUnitGroup","compatibleUnitGroup","convertCSSUnitValue","createCSSUnitValue","sumValueItem","unitMap","entry","toSum","slice","call","arguments","sum","map","some","_construct","CSSMathSum","multiplyTypes","type1","type2","_type1$percentHint","percentHint","finalType","baseType","_step6","canonicalUnits","isCanonical","toLowerCase","groupBy","items","key","reduce","groups","partition","callbackFn","_step","partA","partB","_iterator","_createForOfIteratorHelperLoose","simplifyCalculation","root","info","simplifyNumericArray","Array","from","percentageReference","fontSize","operator","CSSMathNegate","CSSMathClamp","lower","upper","CSSMathMin","CSSMathMax","children","every","child","apply","rest","_partition","hasComparableChildren","combinedGroups","concat","_children3","numericValues","filter","c","nonNumericValues","summedNumericValues","_ref3","a","_ref4","_children5","numbers","product","_ref5","numeric","_step4","_iterator4","installCSSOM","privateDetails","WeakMap","toCssNumericArray","v","i","MathOperation","opt_name","opt_delimiter","this","name","delimiter","toString","details","join","parseCSSMultiplication","str","tokens","split","RegExp","parseCSSDivision","shift","parseCSSNumericValue","trim","match","_","_match$","op","val","parseCSSMathSum","parseMathFunction","parseFloat","parseCSSUnitValue","cssOMTypes","CSSNumericValue","parse","type","displayUnit","CSSKeywordValue","prototype","_MathOperation","_inheritsLoose","_MathOperation2","_MathOperation3","_createClass","_MathOperation4","invertType","_MathOperation5","window","CSS","Reflect","defineProperty","forEach","DEFAULT_TIMELINE_AXIS","scrollTimelineOptions","sourceDetails","scrollEventSource","source","document","scrollingElement","updateInternal","scrollTimelineInstance","validateSource","animations","timelineTime","currentTime","tickAnimation","directionAwareScrollOffset","axis","sourceMeasurements","horizontalWritingMode","getComputedStyle","writingMode","currentScrollOffset","scrollTop","abs","scrollLeft","timeline","ViewTimeline","node","subject","display","updateSource","getScrollParent","anonymousSource","sourceType","getAnonymousSourceElement","anonymousTarget","validateAnonymousSource","measureSource","style","scrollWidth","scrollHeight","clientWidth","clientHeight","direction","scrollPaddingTop","scrollPaddingBottom","scrollPaddingLeft","scrollPaddingRight","measureSubject","top","left","ancestor","offsetParent","offsetLeft","offsetTop","clientLeft","clientTop","offsetWidth","offsetHeight","updateMeasurements","timelineRefs","deref","subjectMeasurements","requestAnimationFrame","oldSource","ref","size","disconnect","resizeObserver","ResizeObserver","_step5","target","observe","mutationObserver","MutationObserver","records","_iterator6","attributes","attributeFilter","scrollListener","_step7","_iterator7","addEventListener","removeEventListener","add","WeakRef","removeAnimation","scrollTimeline","animation","splice","addAnimation","ScrollTimeline","options","inset","undefined","isValidAxis","includes","element","container","scrollerStyle","overflow","unresolved","phase","scrollPos","maxScrollPos","calculateMaxScrollOffset","findClosestAncestor","matcher","candidate","parentElement","isBlockContainer","isFixedElementContainer","transform","perspective","willChange","backdropFilter","isAbsoluteElementContainer","position","getContainingBlock","body","range","optionsInset","rtl","viewSize","viewPos","sizes","scrollPadding","containerSize","start","end","_map","part","simplifiedUnit","calculateInset","coverStartOffset","coverEndOffset","alignStartOffset","alignEndOffset","containStartOffset","min","containEndOffset","max","startOffset","endOffset","targetIsTallerThanContainer","calculateRange","relativePosition","offset","calculateRelativePosition","phaseRange","coverRange","simplifiedRangeOffset","_this","_assertThisInitialized","parts","e","_step8","_iterator8","parseInset","offsets","nativeDocumentGetAnimations","getAnimations","nativeElementGetAnimations","Element","nativeElementAnimate","animate","nativeAnimation","Animation","ANIMATION_RANGE_NAMES","rangeNameRegExp","PromiseWrapper","state","nativeResolve","nativeReject","promise","Promise","resolve","reject","reason","createReadyPromise","readyPromise","_details$timeline$cur","_details$timeline","autoAlignStartTime","pendingTask","startTime","holdTime","commitPendingPause","commitPendingPlay","createAbortError","DOMException","toCssNumberish","_details$rangeDuratio","rangeDuration","limit","effectEnd","fromCssNumberish","_details$rangeDuratio2","duration","convertedTime","applyPendingPlaybackRate","playbackRate","pendingPlaybackRate","currentTimeToMatch","proxy","updateFinishedState","syncCurrentTime","readyTime","commitFinishedNotification","finishedPromise","playState","pause","finishedEvent","CustomEvent","detail","queueMicrotask","dispatchEvent","effectivePlaybackRate","calculateCurrentTime","didSeek","synchronouslyNotify","unconstrainedCurrentTime","pending","upperBound","boundary","previousCurrentTime","calculateStartTime","then","timing","effect","getTiming","normalizedTiming","delay","endDelay","iterations","setNativeCurrentTime","playInternal","autoRewind","abortedPause","hasPendingReadyPromise","bind","proxyAnimations","timelineTimeMs","cancel","renormalizeTiming","specifiedTiming","proxiedAnimations","previousRangeDuration","animationRange","rangeName","fractionalStartDelay","endTime","fractionalEndDelay","ProxyAnimation","animOptions","animationTimeline","isScrollAnimation","parseAnimationRange","finish","Infinity","_proto2","play","reverse","inifiniteDuration","reversable","updatePlaybackRate","rate","persist","resetPendingTasks","callback","event","nativeUpdateTiming","updateTiming","getComputedTimingHandler","_details$duration","localTime","activeDuration","getTimingHandler","thisArg","totalDuration","assign","autoDurationEffect","updateTimingHandler","argumentsList","Proxy","obj","prop","getComputedTiming","createProxyEffect","newEffect","newTimeline","oldTimeline","previousProgress","previousPlayState","fromScrollTimeline","toScrollTimeline","seekTime","silentlySetTheCurrentTime","_proxyAnimations$get$","rangeStart","parseTimelineRangeOffset","_proxyAnimations$get$2","rangeEnd","id","onfinish","oncancel","onremove","finished","ready","Boolean","rangeNames","endsWith","keyframes","proxyAnimation","replaceProxiedAnimations","animationsList","elementGetAnimations","documentGetAnimations","supports","initPolyfill"],"mappings":"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"}